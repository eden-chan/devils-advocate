#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var import_machine_extractor = require("@xstate/machine-extractor");
var import_tools_shared = require("@xstate/tools-shared");
var import_chokidar = require("chokidar");
var import_commander = require("commander");
var fs = __toESM(require("fs/promises"));
var path = __toESM(require("path"));
var import_package = require("../package.json");
const allSettled = (promises) => Promise.all(promises.map((promise) => promise.then((value) => ({ status: "fulfilled", value }), (reason) => ({ status: "rejected", reason }))));
const program = new import_commander.Command();
program.version(import_package.version);
const writeToFiles = (uriArray) => __async(exports, null, function* () {
  yield Promise.all(uriArray.map((uri) => __async(exports, null, function* () {
    try {
      const fileContents = yield fs.readFile(uri, "utf8");
      const extracted = (0, import_machine_extractor.extractMachinesFromFile)(fileContents);
      if (!extracted) {
        return;
      }
      const types = extracted.machines.filter((machineResult) => {
        var _a, _b;
        return !!((_b = (_a = machineResult == null ? void 0 : machineResult.machineCallResult.definition) == null ? void 0 : _a.tsTypes) == null ? void 0 : _b.node);
      }).map((machineResult, index) => (0, import_tools_shared.getTypegenData)(path.basename(uri), index, machineResult));
      yield (0, import_tools_shared.writeToTypegenFile)(uri, types);
      const edits = (0, import_tools_shared.getTsTypesEdits)(types);
      if (edits.length > 0) {
        const newFile = (0, import_tools_shared.processFileEdits)(fileContents, edits);
        yield fs.writeFile(uri, newFile);
      }
      console.log(`${uri} - success`);
    } catch (e) {
      if ((e == null ? void 0 : e.code) === "BABEL_PARSER_SYNTAX_ERROR") {
        console.error(`${uri} - syntax error, skipping`);
      } else {
        console.error(`${uri} - error, `, e);
      }
      throw e;
    }
  })));
});
program.command("typegen").description("Generate TypeScript types from XState machines").argument("<files>", "The files to target, expressed as a glob pattern").option("-w, --watch", "Run the typegen in watch mode").action((filesPattern, opts) => __async(exports, null, function* () {
  if (opts.watch) {
    const processFile = (path2) => {
      if (path2.endsWith(".typegen.ts")) {
        return;
      }
      writeToFiles([path2]).catch(() => {
      });
    };
    (0, import_chokidar.watch)(filesPattern, { awaitWriteFinish: true }).on("add", processFile).on("change", processFile);
  } else {
    const tasks = [];
    (0, import_chokidar.watch)(filesPattern, { persistent: false }).on("add", (path2) => {
      if (path2.endsWith(".typegen.ts")) {
        return;
      }
      tasks.push(writeToFiles([path2]));
    }).on("ready", () => __async(exports, null, function* () {
      const settled = yield allSettled(tasks);
      if (settled.some((result) => result.status === "rejected")) {
        process.exit(1);
      }
      process.exit(0);
    }));
  }
}));
program.parse(process.argv);
