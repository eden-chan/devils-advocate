import * as t from '@babel/types';
import { TextEdit } from '@xstate/tools-shared';
import * as recast from 'recast';
import { Action, Condition } from 'xstate';
import { DeclarationType } from '.';
import { ActionNode, ParsedChooseCondition } from './actions';
import { TMachineCallExpression } from './machineCallExpression';
import { StateNodeReturn } from './stateNode';
import { ToMachineConfigOptions } from './toMachineConfig';
import { TransitionConfigNode } from './transitions';
import { Comment } from './types';
declare const b: import("ast-types/gen/builders").builders;
type RecastObjectExpression = ReturnType<typeof b.objectExpression>;
type RecastNode = InstanceType<typeof recast.types.NodePath>['node'];
type DeletedEntity = {
    type: 'state';
    statePath: string[];
    state: RecastObjectExpression;
} | {
    type: 'transition';
    sourcePath: string[];
    transitionPath: TransitionPath;
    transition: RecastNode;
};
type TransitionPath = [type: 'always', transitionIndex: number] | [type: 'after', delay: string | number, transitionIndex: number] | [type: 'on', event: string, transitionIndex: number] | [type: 'onDone', transitionIndex: number] | [
    type: 'invoke',
    invokeIndex: number,
    event: 'onDone',
    transitionIndex: number
] | [
    type: 'invoke',
    invokeIndex: number,
    event: 'onError',
    transitionIndex: number
];
type ActionPath = [..._: TransitionPath, actionIndex: number] | [type: 'entry', actionIndex: number] | [type: 'exit', actionIndex: number];
export type MachineEdit = {
    type: 'add_state';
    path: string[];
    name: string;
} | {
    type: 'remove_state';
    path: string[];
} | {
    type: 'rename_state';
    path: string[];
    name: string;
} | {
    type: 'reparent_state';
    path: string[];
    newParentPath: string[];
} | {
    type: 'set_initial_state';
    path: string[];
    initialState: string | null;
} | {
    type: 'set_state_id';
    path: string[];
    id: string | null;
} | {
    type: 'set_state_type';
    path: string[];
    stateType: 'normal' | 'parallel' | 'final' | 'history';
    history?: 'shallow' | 'deep';
} | {
    type: 'add_transition';
    sourcePath: string[];
    targetPath: string[] | null;
    transitionPath: TransitionPath;
    external: boolean;
    guard?: string;
} | {
    type: 'remove_transition';
    sourcePath: string[];
    transitionPath: TransitionPath;
} | {
    type: 'reanchor_transition';
    sourcePath: string[];
    newSourcePath?: string[];
    newTargetPath?: string[] | null;
    transitionPath: TransitionPath;
    newTransitionPath?: TransitionPath;
} | {
    type: 'change_transition_path';
    sourcePath: string[];
    transitionPath: TransitionPath;
    newTransitionPath: TransitionPath;
} | {
    type: 'mark_transition_as_external';
    sourcePath: string[];
    transitionPath: TransitionPath;
    external: boolean;
} | {
    type: 'add_action';
    path: string[];
    actionPath: ActionPath;
    name: string;
} | {
    type: 'remove_action';
    path: string[];
    actionPath: ActionPath;
} | {
    type: 'edit_action';
    path: string[];
    actionPath: ActionPath;
    name: string;
} | {
    type: 'add_guard';
    path: string[];
    transitionPath: TransitionPath;
    name: string;
} | {
    type: 'remove_guard';
    path: string[];
    transitionPath: TransitionPath;
} | {
    type: 'edit_guard';
    path: string[];
    transitionPath: TransitionPath;
    name: string;
} | {
    type: 'add_invoke';
    path: string[];
    invokeIndex: number;
    source: string;
    id?: string;
} | {
    type: 'remove_invoke';
    path: string[];
    invokeIndex: number;
} | {
    type: 'edit_invoke';
    path: string[];
    invokeIndex: number;
    source?: string;
    id?: string | null;
} | {
    type: 'set_description';
    statePath: string[];
    transitionPath?: TransitionPath;
    description?: string | null;
} | {
    type: 'update_layout_string';
    layoutString: string;
};
export interface MachineParseResultStateNode {
    path: string[];
    ast: StateNodeReturn;
}
/**
 * Gives some helpers to the user of the lib
 */
export declare class MachineExtractResult {
    machineCallResult: TMachineCallExpression;
    private stateNodes;
    private _fileContent;
    private _fileAst;
    private _idMap;
    constructor(props: {
        fileAst: t.File;
        fileContent: string;
        machineCallResult: TMachineCallExpression;
    });
    private _getAllStateNodes;
    getIsIgnored: () => boolean;
    getChooseActionsToAddToOptions: () => {
        [x: string]: import("xstate").ActionObject<any, any> | ((context: any, event: any, meta: import("xstate").ActionMeta<any, any, any>) => void) | undefined;
    };
    private getChooseActionsInOptions;
    /**
     * Returns the raw value of a comment marked with @xstate-layout.
     *
     * For instance: '@xstate-layout 1234' will return '1234'
     */
    getLayoutComment: () => {
        type: 'inner' | 'outer';
        value: string;
        comment: Comment;
    } | undefined;
    getTransitions: () => {
        config: TransitionConfigNode;
        fromPath: string[];
        transitionPath: TransitionPath;
    }[];
    getTransitionTargets: () => {
        target: {
            node: t.Node;
            value: string;
        }[] & {
            _valueNode?: t.Node;
        };
        fromPath: string[];
        transitionPath: TransitionPath;
        targetPath: (string[] | undefined)[];
    }[];
    getStateNodeByPath: (path: string[]) => MachineParseResultStateNode | undefined;
    getAllStateNodes: () => MachineParseResultStateNode[];
    toConfig: (opts?: Omit<ToMachineConfigOptions, 'fileContent'>) => import("xstate").MachineConfig<any, any, any, import("xstate").BaseActionObject, import("xstate").ServiceMap, import("xstate").TypegenDisabled> | undefined;
    getAllConds: (declarationTypes?: DeclarationType[]) => {
        node: t.Node;
        cond: Condition<any, any>;
        statePath: string[];
        name: string;
        inlineDeclarationId: string;
    }[];
    private getAllActionsInConfig;
    getAllActions: (declarationTypes?: DeclarationType[]) => {
        node: t.Node;
        action: Action<any, any>;
        statePath: string[];
        chooseConditions?: ParsedChooseCondition[];
        name: string;
        inlineDeclarationId: string;
    }[];
    getAllServices: (declarationTypes?: DeclarationType[]) => {
        node: t.Node;
        src: string;
        id: string | undefined;
        statePath: string[];
        srcNode: t.Node | undefined;
        inlineDeclarationId: string;
    }[];
    getAllNamedDelays: () => Record<string, {
        node: t.Node;
        name: string;
        statePath: string[];
    }[]>;
    getActionImplementation: (name: string) => {
        keyNode: t.Node;
        key: string;
        result: ActionNode | {
            node: t.Node;
        };
        property: t.ObjectMethod | t.ObjectProperty | t.SpreadElement;
    } | undefined;
    getServiceImplementation: (name: string) => {
        keyNode: t.Node;
        key: string;
        result: {
            node: t.Node;
        };
        property: t.ObjectMethod | t.ObjectProperty | t.SpreadElement;
    } | undefined;
    getGuardImplementation: (name: string) => {
        keyNode: t.Node;
        key: string;
        result: {
            node: t.Node;
        };
        property: t.ObjectMethod | t.ObjectProperty | t.SpreadElement;
    } | undefined;
    modify(edits: Array<MachineEdit>): {
        layoutEdit: TextEdit | undefined;
        configEdit: TextEdit;
        deleted: DeletedEntity[] | undefined;
    };
    restore({ deleted }: {
        deleted: DeletedEntity[];
    }): {
        configEdit: {
            type: "replace";
            range: readonly [{
                readonly line: number;
                readonly column: number;
                readonly index: number;
            }, {
                readonly line: number;
                readonly column: number;
                readonly index: number;
            }];
            newText: string;
        };
    };
}
export {};
