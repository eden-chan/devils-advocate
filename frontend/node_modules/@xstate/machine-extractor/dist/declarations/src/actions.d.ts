import * as t from '@babel/types';
import { Action, ChooseCondition } from 'xstate';
import { CondNode } from './conds';
import { DeclarationType } from './types';
export interface ActionNode {
    node: t.Node;
    action: Action<any, any>;
    name: string;
    chooseConditions?: ParsedChooseCondition[];
    declarationType: DeclarationType;
    inlineDeclarationId: string;
}
export interface ParsedChooseCondition {
    condition: ChooseCondition<any, any>;
    actionNodes: ActionNode[];
    conditionNode?: CondNode;
}
export declare const ActionAsIdentifier: import("./types").AnyParser<ActionNode>;
export declare const ActionAsFunctionExpression: import("./types").AnyParser<ActionNode>;
export declare const ActionAsString: import("./types").AnyParser<ActionNode>;
export declare const ActionAsNode: import("./types").Parser<t.Node, ActionNode>;
export declare const ChooseAction: import("./types").AnyParser<ActionNode>;
export declare const AssignAction: import("./types").AnyParser<ActionNode>;
export declare const SendActionSecondArg: import("./types").AnyParser<import("./utils").GetObjectKeysResult<{
    to: import("./types").AnyParser<{
        node: t.Node;
        value: string;
    }>;
    delay: import("./types").AnyParser<{
        node: t.Node;
        value: string | number;
    }>;
    id: import("./types").AnyParser<{
        node: t.Node;
        value: string;
    }>;
}>>;
export declare const SendAction: import("./types").AnyParser<ActionNode>;
export declare const ForwardToActionSecondArg: import("./types").AnyParser<import("./utils").GetObjectKeysResult<{
    to: import("./types").AnyParser<{
        node: t.Node;
        value: string;
    }>;
}>>;
export declare const ForwardToAction: import("./types").AnyParser<ActionNode>;
export declare const ArrayOfBasicActions: import("./types").AnyParser<ActionNode[]>;
export declare const MaybeArrayOfActions: import("./types").AnyParser<ActionNode[]>;
