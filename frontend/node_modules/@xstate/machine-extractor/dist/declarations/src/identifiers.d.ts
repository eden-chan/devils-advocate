import * as t from '@babel/types';
import { AnyParser } from './types';
/**
 * Finds a declarator in the same file which corresponds
 * to an identifier of the name you provide
 */
export declare const findVariableDeclaratorWithName: (file: any, name: string) => t.VariableDeclarator | null | undefined;
/**
 * Used for when you expect an identifier to be used
 * which references a variable declaration of a certain type
 */
export declare const identifierReferencingVariableDeclaration: <Result>(parser: AnyParser<Result>) => import("./types").Parser<t.Identifier, Result | undefined>;
/**
 * Finds a declarator in the same file which corresponds
 * to an identifier of the name you provide
 */
export declare const findTSEnumDeclarationWithName: (file: any, name: string) => t.TSEnumDeclaration | null | undefined;
export declare const objectExpressionWithDeepPath: <Result>(path: string[], parser: AnyParser<Result>) => import("./types").Parser<t.ObjectExpression, Result | undefined>;
export declare const memberExpressionReferencingObjectExpression: <Result>(parser: AnyParser<Result>) => import("./types").Parser<t.MemberExpression, Result | undefined>;
export declare const memberExpressionReferencingEnumMember: import("./types").Parser<t.MemberExpression, {
    node: t.TSEnumMember;
    value: string;
} | undefined>;
export declare const maybeIdentifierTo: <Result>(parser: AnyParser<Result>) => AnyParser<Result>;
