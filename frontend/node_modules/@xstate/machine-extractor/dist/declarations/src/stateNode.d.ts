import * as t from '@babel/types';
import { MaybeArrayOfActions } from './actions';
import { Context } from './context';
import { History } from './history';
import { Invoke } from './invoke';
import { StateMeta } from './meta';
import { AnyNode, BooleanLiteral, StringLiteral } from './scalars';
import { Schema } from './schema';
import { MaybeTransitionArray } from './transitions';
import { TsTypes } from './tsTypes';
import { AnyParser } from './types';
import { GetParserResult, ObjectOfReturn, ObjectPropertyInfo } from './utils';
declare const On: AnyParser<ObjectOfReturn<import("./utils").GetObjectKeysResult<{
    target: AnyParser<{
        node: t.Node;
        value: string;
    }[]>;
    actions: AnyParser<import("./actions").ActionNode[]>;
    cond: AnyParser<import("./conds").CondNode | null>;
    description: AnyParser<{
        node: t.Node;
        value: string;
    }>;
}>[]>>;
declare const After: AnyParser<ObjectOfReturn<import("./utils").GetObjectKeysResult<{
    target: AnyParser<{
        node: t.Node;
        value: string;
    }[]>;
    actions: AnyParser<import("./actions").ActionNode[]>;
    cond: AnyParser<import("./conds").CondNode | null>;
    description: AnyParser<{
        node: t.Node;
        value: string;
    }>;
}>[]>>;
declare const Tags: AnyParser<{
    node: t.Node;
    value: string;
}[]>;
type WithValueNodes<T> = {
    [K in keyof T]: T[K] & {
        _valueNode?: t.Node;
    };
};
/**
 * This is frustrating, but we need to keep this
 * up to date with the StateNode definition below.
 *
 * The reason? TS fails early when it hits a
 * recursive type definition, meaning our inference
 * falls out the window when StateNode tries to
 * reference itself
 */
export type StateNodeReturn = WithValueNodes<{
    id?: GetParserResult<typeof StringLiteral>;
    initial?: GetParserResult<typeof StringLiteral>;
    type?: GetParserResult<typeof StringLiteral>;
    entry?: GetParserResult<typeof MaybeArrayOfActions>;
    exit?: GetParserResult<typeof MaybeArrayOfActions>;
    onEntry?: GetParserResult<typeof MaybeArrayOfActions>;
    onExit?: GetParserResult<typeof MaybeArrayOfActions>;
    invoke?: GetParserResult<typeof Invoke>;
    always?: GetParserResult<typeof MaybeTransitionArray>;
    onDone?: GetParserResult<typeof MaybeTransitionArray>;
    on?: GetParserResult<typeof On>;
    after?: GetParserResult<typeof After>;
    history?: GetParserResult<typeof History>;
    tags?: GetParserResult<typeof Tags>;
    states?: GetParserResult<AnyParser<ObjectOfReturn<StateNodeReturn>>>;
    meta?: GetParserResult<typeof StateMeta>;
    data?: GetParserResult<typeof AnyNode>;
    parallel?: GetParserResult<typeof BooleanLiteral>;
    description?: GetParserResult<typeof StringLiteral>;
    activities?: GetParserResult<typeof AnyNode>;
    tsTypes?: GetParserResult<typeof TsTypes>;
    schema?: GetParserResult<typeof Schema>;
    context?: GetParserResult<typeof Context>;
    preserveActionOrder?: GetParserResult<typeof BooleanLiteral>;
    predictableActionArguments?: GetParserResult<typeof BooleanLiteral>;
    strict?: GetParserResult<typeof BooleanLiteral>;
    version?: GetParserResult<typeof AnyNode>;
    delimiter?: GetParserResult<typeof StringLiteral>;
    key?: GetParserResult<typeof StringLiteral>;
}> & Pick<ObjectPropertyInfo, 'node'>;
export declare const StateNode: AnyParser<StateNodeReturn>;
export {};
