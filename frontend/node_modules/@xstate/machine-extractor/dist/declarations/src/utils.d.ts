import * as t from '@babel/types';
import { AnyParser, ParserContext } from './types';
export declare const parserFromBabelMatcher: <T extends t.Node>(babelMatcher: (node: any) => node is T) => import("./types").Parser<T, T>;
/**
 * Useful for when something might, or might not,
 * be declared as an array
 */
export declare const maybeArrayOf: <Result>(parser: AnyParser<Result> | AnyParser<Result[]>) => AnyParser<Result[]>;
/**
 * Used to declare that this node is declared
 * an array of something
 */
export declare const arrayOf: <Result>(parser: AnyParser<Result>) => AnyParser<Result[]>;
export declare const objectMethod: import("./types").Parser<t.ObjectMethod, {
    node: t.ObjectMethod;
    key: {
        node: t.Identifier;
        value: string;
    } | undefined;
}>;
export declare const staticObjectProperty: <KeyResult>(keyParser: AnyParser<KeyResult>) => import("./types").Parser<t.ObjectProperty, {
    node: t.ObjectProperty;
    key: KeyResult | undefined;
}>;
export declare const spreadElement: <Result>(parser: AnyParser<Result>) => import("./types").Parser<t.SpreadElement, {
    node: t.SpreadElement;
    argumentResult: Result | undefined;
}>;
export declare const spreadElementReferencingIdentifier: <Result>(parser: AnyParser<Result>) => import("./types").Parser<t.SpreadElement, {
    node: t.SpreadElement;
    argumentResult: Result | undefined;
}>;
export declare const dynamicObjectProperty: <KeyResult>(keyParser: AnyParser<KeyResult>) => import("./types").Parser<t.ObjectProperty, {
    node: t.ObjectProperty;
    key: KeyResult | undefined;
}>;
/**
 * Utility function for grabbing the properties of
 * an object expression
 */
export declare const getPropertiesOfObjectExpression: (node: t.ObjectExpression | undefined, context: ParserContext) => {
    node: t.ObjectProperty | t.ObjectMethod;
    key: string;
    keyNode: t.Node;
    property: t.ObjectMethod | t.ObjectProperty | t.SpreadElement;
}[];
export type GetObjectKeysResult<T extends {
    [index: string]: AnyParser<unknown>;
}> = {
    [K in keyof T]?: ReturnType<T[K]['parse']> & {
        _valueNode?: t.Node;
    };
} & {
    node: t.Node;
};
export interface ObjectPropertyInfo {
    node: t.Node;
    _valueNode?: t.Node;
}
export type GetParserResult<TParser extends AnyParser<any>> = NonNullable<ReturnType<TParser['parse']>>;
/**
 * Used for declaring an object expression where the known keys
 * can be different things
 */
export declare const objectTypeWithKnownKeys: <T extends {
    [index: string]: AnyParser<any>;
}>(parserObject: T | (() => T)) => AnyParser<GetObjectKeysResult<T>>;
export interface ObjectOfReturn<Result> {
    node: t.Node;
    properties: {
        keyNode: t.Node;
        key: string;
        result: Result;
        property: t.ObjectMethod | t.ObjectProperty | t.SpreadElement;
    }[];
}
/**
 * Used when you have a keyed object where all the
 * values are the same type, for instance `states` or
 * `on`
 */
export declare const objectOf: <Result>(parser: AnyParser<Result>) => AnyParser<ObjectOfReturn<Result>>;
/**
 * Returns a parser for a named function and allows you to
 * parse its arguments
 */
export declare const namedFunctionCall: <Argument1Result, Argument2Result>(name: string, argument1Parser: AnyParser<Argument1Result>, argument2Parser?: AnyParser<Argument2Result> | undefined) => AnyParser<{
    node: t.CallExpression;
    argument1Result: Argument1Result | undefined;
    argument2Result: Argument2Result | undefined;
}>;
export declare const isFunctionOrArrowFunctionExpression: (node: any) => node is t.ArrowFunctionExpression | t.FunctionExpression;
export declare function hashedId(str: string): string;
