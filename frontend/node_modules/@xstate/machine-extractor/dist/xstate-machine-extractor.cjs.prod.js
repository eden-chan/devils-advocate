'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var types = require('xstate/lib/types');
var t = require('@babel/types');
var actions = require('xstate/lib/actions');
var traverse = require('@babel/traverse');
var recast = require('recast');
var parser = require('@babel/parser');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespace(t);
var traverse__default = /*#__PURE__*/_interopDefault(traverse);
var recast__namespace = /*#__PURE__*/_interopNamespace(recast);

const INLINE_IMPLEMENTATION_TYPE = '_inline';

/**
 * Creates a parser, which can be run later on AST nodes
 * to work out if they match
 */
const createParser = params => {
  const matches = node => {
    return params.babelMatcher(node);
  };

  const parse = (node, context) => {
    if (!matches(node)) return undefined;
    return params.parseNode(node, context);
  };

  return {
    parse,
    matches
  };
};

/**
 * Used to declare when a type can be either one
 * thing or another. Each parser added must
 * return the same result
 */
const unionType = parsers => {
  const matches = node => {
    return parsers.some(parser => parser.matches(node));
  };

  const parse = (node, context) => {
    for (const parser of parsers) {
      if (!parser.matches(node)) {
        continue;
      }

      const result = parser.parse(node, context);

      if (result) {
        return result;
      }
    }
  };

  return {
    matches,
    parse
  };
};

/**
 * Allows you to wrap a parser and reformulate
 * the result at the end of it
 */
const wrapParserResult = (parser, changeResult) => {
  return {
    matches: parser.matches,
    parse: (node, context) => {
      const result = parser.parse(node, context);
      if (!result) return undefined;
      return changeResult(result, node, context);
    }
  };
};

/**
 * Finds a declarator in the same file which corresponds
 * to an identifier of the name you provide
 */

const findVariableDeclaratorWithName = (file, name) => {
  let declarator = null;
  traverse__default['default'](file, {
    VariableDeclarator(path) {
      if (t__namespace.isIdentifier(path.node.id) && path.node.id.name === name) {
        declarator = path.node;
      }
    }

  });
  return declarator;
};
/**
 * Used for when you expect an identifier to be used
 * which references a variable declaration of a certain type
 */

const identifierReferencingVariableDeclaration = parser => {
  return createParser({
    babelMatcher: t__namespace.isIdentifier,
    parseNode: (node, context) => {
      const variableDeclarator = findVariableDeclaratorWithName(context.file, node.name);
      return parser.parse(variableDeclarator === null || variableDeclarator === void 0 ? void 0 : variableDeclarator.init, context);
    }
  });
};
/**
 * Finds a declarator in the same file which corresponds
 * to an identifier of the name you provide
 */

const findTSEnumDeclarationWithName = (file, name) => {
  let declarator = null;
  traverse__default['default'](file, {
    TSEnumDeclaration(path) {
      if (t__namespace.isIdentifier(path.node.id) && path.node.id.name === name) {
        declarator = path.node;
      }
    }

  });
  return declarator;
};

const deepMemberExpressionToPath = memberExpression => {
  let currentLevel = memberExpression;
  const path = [];

  while (currentLevel) {
    if (t__namespace.isIdentifier(currentLevel.node)) {
      path.push(currentLevel.node.name);
    } else if (t__namespace.isMemberExpression(currentLevel.node) && t__namespace.isIdentifier(currentLevel.node.property)) {
      path.push(currentLevel.node.property.name);
    }

    currentLevel = currentLevel.child;
  }

  return path.reverse();
};

const deepMemberExpression = createParser({
  babelMatcher(node) {
    return t__namespace.isIdentifier(node) || t__namespace.isMemberExpression(node);
  },

  parseNode: (node, context) => {
    return {
      node,
      child: 'object' in node ? deepMemberExpression.parse(node.object, context) : undefined
    };
  }
});
const objectExpressionWithDeepPath = (path, parser) => createParser({
  babelMatcher: t__namespace.isObjectExpression,
  parseNode: (node, context) => {
    let currentIndex = 0;
    let currentNode = node;

    while (path[currentIndex]) {
      var _objectProperties$fin, _objectProperties$fin2;

      const pathSection = path[currentIndex];
      const objectProperties = getPropertiesOfObjectExpression(currentNode, context);
      currentNode = (_objectProperties$fin = objectProperties.find(property => property.key === pathSection && t__namespace.isObjectProperty(property.node))) === null || _objectProperties$fin === void 0 ? void 0 : (_objectProperties$fin2 = _objectProperties$fin.node) === null || _objectProperties$fin2 === void 0 ? void 0 : _objectProperties$fin2.value;
      currentIndex++;
    }

    return parser.parse(currentNode, context);
  }
});

const getRootIdentifierOfDeepMemberExpression = deepMemberExpression => {
  if (!deepMemberExpressionToPath) return undefined;

  if (t__namespace.isIdentifier(deepMemberExpression === null || deepMemberExpression === void 0 ? void 0 : deepMemberExpression.node)) {
    return deepMemberExpression === null || deepMemberExpression === void 0 ? void 0 : deepMemberExpression.node;
  }

  return getRootIdentifierOfDeepMemberExpression(deepMemberExpression === null || deepMemberExpression === void 0 ? void 0 : deepMemberExpression.child);
};

const memberExpressionReferencingObjectExpression = parser => createParser({
  babelMatcher: t__namespace.isMemberExpression,
  parseNode: (node, context) => {
    const result = deepMemberExpression.parse(node, context);
    const rootIdentifier = getRootIdentifierOfDeepMemberExpression(result);
    if (!result) return undefined;
    const path = deepMemberExpressionToPath(result);
    return identifierReferencingVariableDeclaration(objectExpressionWithDeepPath(path.slice(1), parser)).parse(rootIdentifier, context);
  }
});
const memberExpressionReferencingEnumMember = createParser({
  babelMatcher: t__namespace.isMemberExpression,
  parseNode: (node, context) => {
    const result = deepMemberExpression.parse(node, context);
    const rootIdentifier = getRootIdentifierOfDeepMemberExpression(result);
    if (!result) return undefined;
    const path = deepMemberExpressionToPath(result);
    const foundEnum = findTSEnumDeclarationWithName(context.file, rootIdentifier === null || rootIdentifier === void 0 ? void 0 : rootIdentifier.name);
    if (!foundEnum) return undefined;
    const targetEnumMember = path[1];
    const valueParser = unionType([wrapParserResult(parserFromBabelMatcher(t__namespace.isStringLiteral), node => node.value), wrapParserResult(parserFromBabelMatcher(t__namespace.isIdentifier), node => node.name)]);
    const memberIndex = foundEnum.members.findIndex(member => {
      const value = valueParser.parse(member.id, context);
      return value === targetEnumMember;
    });
    const member = foundEnum.members[memberIndex];

    if (!member) {
      return undefined;
    }

    if (member !== null && member !== void 0 && member.initializer) {
      return {
        node: member,
        value: unionType([wrapParserResult(parserFromBabelMatcher(t__namespace.isStringLiteral), node => node.value), wrapParserResult(parserFromBabelMatcher(t__namespace.isNumericLiteral), node => String(node.value))]).parse(member.initializer, context)
      };
    } else {
      return {
        node: member,
        value: String(memberIndex)
      };
    }
  }
});
const maybeIdentifierTo = parser => {
  return unionType([parser, identifierReferencingVariableDeclaration(parser), memberExpressionReferencingObjectExpression(parser)]);
};

const tsAsExpression = parser => {
  return createParser({
    babelMatcher: t__namespace.isTSAsExpression,
    parseNode: (node, context) => {
      if (parser.matches(node.expression)) {
        return parser.parse(node.expression, context);
      }
    }
  });
};
const maybeTsAsExpression = parser => {
  return unionType([parser, tsAsExpression(parser)]);
};

const StringLiteral = unionType([wrapParserResult(memberExpressionReferencingEnumMember, node => {
  return {
    node: node.node,
    value: node.value
  };
}), maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: t__namespace.isStringLiteral,
  parseNode: node => {
    return {
      value: node.value,
      node
    };
  }
})))]);
const NumericLiteral = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: t__namespace.isNumericLiteral,
  parseNode: node => {
    return {
      value: node.value,
      node
    };
  }
})));
const BooleanLiteral = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: t__namespace.isBooleanLiteral,
  parseNode: node => {
    return {
      value: node.value,
      node
    };
  }
})));
const AnyNode = createParser({
  babelMatcher: t__namespace.isNode,
  parseNode: node => ({
    node
  })
});
const Identifier = createParser({
  babelMatcher: t__namespace.isIdentifier,
  parseNode: node => ({
    node
  })
});
const TemplateLiteral = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: t__namespace.isTemplateLiteral,
  parseNode: node => {
    let value = ''; // TODO - this might lead to weird issues if there is actually more than a single quasi there

    node.quasis.forEach(quasi => {
      value = `${value}${quasi.value.raw}`;
    });
    return {
      node,
      value
    };
  }
})));

const parserFromBabelMatcher = babelMatcher => createParser({
  babelMatcher,
  parseNode: node => node
});
/**
 * Useful for when something might, or might not,
 * be declared as an array
 */

const maybeArrayOf = parser => {
  const arrayParser = createParser({
    babelMatcher: t__namespace.isArrayExpression,
    parseNode: (node, context) => {
      const toReturn = [];
      node.elements.map(elem => {
        const result = parser.parse(elem, context);

        if (result && Array.isArray(result)) {
          toReturn.push(...result);
        } else if (result) {
          toReturn.push(result);
        }
      });
      return toReturn;
    }
  });
  const otherParser = wrapParserResult(parser, res => {
    if (Array.isArray(res)) {
      return res;
    }

    return [res];
  });
  return unionType([arrayParser, otherParser]);
};
/**
 * Used to declare that this node is declared
 * an array of something
 */

const arrayOf = parser => {
  return createParser({
    babelMatcher: t__namespace.isArrayExpression,
    parseNode: (node, context) => {
      const toReturn = [];
      node.elements.map(elem => {
        const result = parser.parse(elem, context);

        if (result) {
          toReturn.push(result);
        }
      });
      return toReturn;
    }
  });
};
const objectMethod = createParser({
  babelMatcher: t__namespace.isObjectMethod,
  parseNode: (node, context) => {
    return {
      node,
      key: wrapParserResult(Identifier, ({
        node
      }) => ({
        node: node,
        value: node.name
      })).parse(node.key, context)
    };
  }
});
const staticObjectProperty = keyParser => createParser({
  babelMatcher: node => {
    return t__namespace.isObjectProperty(node) && !node.computed;
  },
  parseNode: (node, context) => {
    return {
      node,
      key: keyParser.parse(node.key, context)
    };
  }
});
const spreadElement = parser => {
  return createParser({
    babelMatcher: t__namespace.isSpreadElement,
    parseNode: (node, context) => {
      const result = {
        node,
        argumentResult: parser.parse(node.argument, context)
      };
      return result;
    }
  });
};
const spreadElementReferencingIdentifier = parser => {
  return spreadElement(identifierReferencingVariableDeclaration(parser));
};
const dynamicObjectProperty = keyParser => createParser({
  babelMatcher: node => {
    return t__namespace.isObjectProperty(node) && node.computed;
  },
  parseNode: (node, context) => {
    return {
      node,
      key: keyParser.parse(node.key, context)
    };
  }
});
const staticPropertyWithKey = staticObjectProperty(unionType([createParser({
  babelMatcher: t__namespace.isIdentifier,
  parseNode: node => {
    return {
      node,
      value: node.name
    };
  }
}), StringLiteral, NumericLiteral]));
const dynamicPropertyWithKey = dynamicObjectProperty(maybeIdentifierTo(unionType([StringLiteral, NumericLiteral, TemplateLiteral])));
const propertyKey = unionType([objectMethod, staticPropertyWithKey, dynamicPropertyWithKey]);
/**
 * Utility function for grabbing the properties of
 * an object expression
 */

const getPropertiesOfObjectExpression = (node, context) => {
  const propertiesToReturn = [];
  node === null || node === void 0 ? void 0 : node.properties.forEach(property => {
    var _spreadElementResult$;

    const propertiesToParse = [property];
    const spreadElementResult = spreadElementReferencingIdentifier(createParser({
      babelMatcher: t__namespace.isObjectExpression,
      parseNode: node => node
    })).parse(property, context);
    propertiesToParse.push(...((spreadElementResult === null || spreadElementResult === void 0 ? void 0 : (_spreadElementResult$ = spreadElementResult.argumentResult) === null || _spreadElementResult$ === void 0 ? void 0 : _spreadElementResult$.properties) || []));
    propertiesToParse.forEach(property => {
      const result = propertyKey.parse(property, context);

      if (result && result !== null && result !== void 0 && result.key) {
        var _result$key;

        propertiesToReturn.push({
          key: `${(_result$key = result.key) === null || _result$key === void 0 ? void 0 : _result$key.value}`,
          node: result.node,
          keyNode: result.key.node,
          property
        });
      }
    });
  });
  return propertiesToReturn;
};

/**
 * Used for declaring an object expression where the known keys
 * can be different things
 */
const objectTypeWithKnownKeys = parserObject => maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: t__namespace.isObjectExpression,
  parseNode: (node, context) => {
    const properties = getPropertiesOfObjectExpression(node, context);
    const parseObject = typeof parserObject === 'function' ? parserObject() : parserObject;
    const toReturn = {
      node
    };
    properties === null || properties === void 0 ? void 0 : properties.forEach(property => {
      const key = property.key;
      const parser = parseObject[key];
      if (!parser) return;
      let result;

      if (t__namespace.isObjectMethod(property.node)) {
        result = parser.parse(property.node, context);
      } else if (t__namespace.isObjectProperty(property.node)) {
        result = parser.parse(property.node.value, context);

        if (result) {
          result._valueNode = property.node.value;
        }
      }

      toReturn[key] = result;
    });
    return toReturn;
  }
})));

/**
 * Used when you have a keyed object where all the
 * values are the same type, for instance `states` or
 * `on`
 */
const objectOf = parser => {
  return maybeIdentifierTo(createParser({
    babelMatcher: t__namespace.isObjectExpression,
    parseNode: (node, context) => {
      const properties = getPropertiesOfObjectExpression(node, context);
      const toReturn = {
        node,
        properties: []
      };
      properties.forEach(property => {
        let result;

        if (t__namespace.isObjectMethod(property.node)) {
          result = parser.parse(property.node, context);
        } else if (t__namespace.isObjectProperty(property.node)) {
          result = parser.parse(property.node.value, context);
        }

        if (result) {
          toReturn.properties.push({
            key: property.key,
            keyNode: property.keyNode,
            result,
            property: property.property
          });
        }
      });
      return toReturn;
    }
  }));
};
/**
 * Returns a parser for a named function and allows you to
 * parse its arguments
 */

const namedFunctionCall = (name, argument1Parser, argument2Parser) => {
  const namedFunctionParser = maybeTsAsExpression(maybeIdentifierTo(createParser({
    babelMatcher: t__namespace.isCallExpression,
    parseNode: node => {
      return node;
    }
  })));
  return {
    matches: node => {
      if (!namedFunctionParser.matches(node)) {
        return false;
      }

      if (!t__namespace.isIdentifier(node.callee)) {
        return false;
      }

      return node.callee.name === name;
    },
    parse: (node, context) => {
      return {
        node,
        argument1Result: argument1Parser.parse(node.arguments[0], context),
        argument2Result: argument2Parser === null || argument2Parser === void 0 ? void 0 : argument2Parser.parse(node.arguments[1], context)
      };
    }
  };
};
const isFunctionOrArrowFunctionExpression = node => {
  return t__namespace.isArrowFunctionExpression(node) || t__namespace.isFunctionExpression(node);
};
function hashedId(str) {
  return hash(str.replace(/\s/g, ''));
}
/**
 * Thanks, stack overflow!
 */

function hash(str) {
  return str.split('').reduce((prevHash, currVal) => (prevHash << 5) - prevHash + currVal.charCodeAt(0) | 0, 0).toString(32).substring(1, 10);
}

const CondAsFunctionExpression = createParser({
  babelMatcher: isFunctionOrArrowFunctionExpression,
  parseNode: (node, context) => {
    return {
      node,
      name: '',
      cond: () => {
        return false;
      },
      declarationType: 'inline',
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
});
const CondAsStringLiteral = createParser({
  babelMatcher: t__namespace.isStringLiteral,
  parseNode: (node, context) => {
    return {
      node,
      name: node.value,
      cond: node.value,
      declarationType: 'named',
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
});
const CondAsParametrizedGuard = createParser({
  babelMatcher: t__namespace.isObjectExpression,
  parseNode: (node, context) => {
    let propValue = null;

    for (const prop of node.properties) {
      if (!t__namespace.isObjectProperty(prop) || prop.computed) {
        continue;
      }

      if (t__namespace.isStringLiteral(prop.key) && prop.key.value === 'type' || t__namespace.isIdentifier(prop.key) && prop.key.name === 'type') {
        propValue = prop.value;
        break;
      }
    }

    if (!propValue || !t__namespace.isStringLiteral(propValue)) {
      return null;
    }

    const id = context.getNodeHash(node);
    return {
      node,
      name: propValue.value,
      cond: propValue.value,
      declarationType: 'named',
      inlineDeclarationId: id
    };
  }
});
const CondAsNode = createParser({
  babelMatcher: t__namespace.isNode,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      node,
      name: '',
      cond: id,
      declarationType: 'unknown',
      inlineDeclarationId: id
    };
  }
});
const Cond = unionType([CondAsFunctionExpression, CondAsStringLiteral, CondAsParametrizedGuard, CondAsNode]);

const AfterAction = wrapParserResult(namedFunctionCall('after', unionType([StringLiteral, NumericLiteral])), (result, node, context) => {
  var _result$argument1Resu;

  return {
    node: result.node,
    action: actions.after(((_result$argument1Resu = result.argument1Result) === null || _result$argument1Resu === void 0 ? void 0 : _result$argument1Resu.value) || ''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const CancelAction = wrapParserResult(namedFunctionCall('cancel', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.cancel(''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const DoneAction = wrapParserResult(namedFunctionCall('done', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.done(''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const EscalateAction = wrapParserResult(namedFunctionCall('escalate', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.escalate(''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const LogAction = wrapParserResult(namedFunctionCall('log', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.log(),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const PureAction = wrapParserResult(namedFunctionCall('pure', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.pure(() => []),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const RaiseAction = wrapParserResult(namedFunctionCall('raise', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.raise(''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const RespondAction = wrapParserResult(namedFunctionCall('respond', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.respond(''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const SendParentAction = wrapParserResult(namedFunctionCall('sendParent', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.sendParent(''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const SendUpdateAction = wrapParserResult(namedFunctionCall('sendUpdate', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.sendUpdate(),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const StartAction = wrapParserResult(namedFunctionCall('start', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.start(''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const StopAction = wrapParserResult(namedFunctionCall('stop', AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.stop(''),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});

const ActionAsIdentifier = maybeTsAsExpression(createParser({
  babelMatcher: t__namespace.isIdentifier,
  parseNode: (node, context) => {
    return {
      action: node.name,
      node,
      name: node.name,
      declarationType: 'identifier',
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
}));
const ActionAsFunctionExpression = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: isFunctionOrArrowFunctionExpression,
  parseNode: (node, context) => {
    const action = function actions() {};

    const id = context.getNodeHash(node);

    action.toJSON = () => id;

    return {
      node,
      action,
      name: '',
      declarationType: 'inline',
      inlineDeclarationId: id
    };
  }
})));
const ActionAsString = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: t__namespace.isStringLiteral,
  parseNode: (node, context) => {
    return {
      action: node.value,
      node,
      name: node.value,
      declarationType: 'named',
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
})));
const ActionAsNode = createParser({
  babelMatcher: t__namespace.isNode,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      action: id,
      node,
      name: '',
      declarationType: 'unknown',
      inlineDeclarationId: id
    };
  }
});
const ChooseFirstArg = arrayOf(objectTypeWithKnownKeys({
  cond: Cond,
  // Don't allow choose inside of choose for now,
  // too recursive
  // TODO - fix
  actions: maybeArrayOf(ActionAsString)
}));
const ChooseAction = wrapParserResult(namedFunctionCall('choose', ChooseFirstArg), (result, node, context) => {
  var _result$argument1Resu;

  const conditions = [];
  (_result$argument1Resu = result.argument1Result) === null || _result$argument1Resu === void 0 ? void 0 : _result$argument1Resu.forEach(arg1Result => {
    const toPush = {
      condition: {
        actions: []
      },
      actionNodes: []
    };

    if (arg1Result.actions) {
      const actionResult = arg1Result.actions.map(action => action.action);

      if (actionResult.length === 1) {
        toPush.condition.actions = actionResult[0];
      } else {
        toPush.condition.actions = actionResult;
      }

      toPush.actionNodes = arg1Result.actions;
    }

    if (arg1Result.cond) {
      toPush.condition.cond = arg1Result.cond.cond;
      toPush.conditionNode = arg1Result.cond;
    }

    conditions.push(toPush);
  });
  return {
    node: node,
    action: actions.choose(conditions.map(condition => condition.condition)),
    chooseConditions: conditions,
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const AssignFirstArgObject = createParser({
  babelMatcher: t__namespace.isObjectExpression,
  parseNode: (node, context) => {
    return {
      node,
      value: {}
    };
  }
});
const AssignFirstArgFunction = createParser({
  babelMatcher: isFunctionOrArrowFunctionExpression,
  parseNode: (node, context) => {
    const value = function anonymous() {
      return {};
    };

    value.toJSON = () => {
      return {};
    };

    return {
      node,
      value
    };
  }
});
const AssignFirstArg = unionType([AssignFirstArgObject, AssignFirstArgFunction]);
const AssignAction = wrapParserResult(namedFunctionCall('assign', AssignFirstArg), (result, node, context) => {
  var _result$argument1Resu2;

  const defaultAction = function anonymous() {
    return {};
  };

  defaultAction.toJSON = () => {
    return {};
  };

  return {
    node: result.node,
    action: actions.assign(((_result$argument1Resu2 = result.argument1Result) === null || _result$argument1Resu2 === void 0 ? void 0 : _result$argument1Resu2.value) || defaultAction),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const SendActionSecondArg = objectTypeWithKnownKeys({
  to: StringLiteral,
  delay: unionType([NumericLiteral, StringLiteral]),
  id: StringLiteral
});
const SendAction = wrapParserResult(namedFunctionCall('send', unionType([StringLiteral, AnyNode]), SendActionSecondArg), (result, node, context) => {
  var _result$argument1Resu3, _result$argument2Resu, _result$argument2Resu2, _result$argument2Resu3, _result$argument2Resu4, _result$argument2Resu5, _result$argument2Resu6;

  return {
    node: result.node,
    name: '',
    action: actions.send(((_result$argument1Resu3 = result.argument1Result) === null || _result$argument1Resu3 === void 0 ? void 0 : _result$argument1Resu3.value) ?? (() => {
      return {
        type: 'UNDEFINED'
      };
    }), { ...(((_result$argument2Resu = result.argument2Result) === null || _result$argument2Resu === void 0 ? void 0 : (_result$argument2Resu2 = _result$argument2Resu.id) === null || _result$argument2Resu2 === void 0 ? void 0 : _result$argument2Resu2.value) && {
        id: result.argument2Result.id.value
      }),
      ...(((_result$argument2Resu3 = result.argument2Result) === null || _result$argument2Resu3 === void 0 ? void 0 : (_result$argument2Resu4 = _result$argument2Resu3.to) === null || _result$argument2Resu4 === void 0 ? void 0 : _result$argument2Resu4.value) && {
        to: result.argument2Result.to.value
      }),
      ...(((_result$argument2Resu5 = result.argument2Result) === null || _result$argument2Resu5 === void 0 ? void 0 : (_result$argument2Resu6 = _result$argument2Resu5.delay) === null || _result$argument2Resu6 === void 0 ? void 0 : _result$argument2Resu6.value) && {
        delay: result.argument2Result.delay.value
      })
    }),
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const ForwardToActionSecondArg = objectTypeWithKnownKeys({
  to: StringLiteral
});
const ForwardToAction = wrapParserResult(namedFunctionCall('forwardTo', StringLiteral, ForwardToActionSecondArg), (result, node, context) => {
  var _result$argument1Resu4, _result$argument2Resu7, _result$argument2Resu8;

  return {
    node: result.node,
    action: actions.forwardTo(((_result$argument1Resu4 = result.argument1Result) === null || _result$argument1Resu4 === void 0 ? void 0 : _result$argument1Resu4.value) || '', { ...(((_result$argument2Resu7 = result.argument2Result) === null || _result$argument2Resu7 === void 0 ? void 0 : (_result$argument2Resu8 = _result$argument2Resu7.to) === null || _result$argument2Resu8 === void 0 ? void 0 : _result$argument2Resu8.value) && {
        to: result.argument2Result.to.value
      })
    }),
    name: '',
    declarationType: 'inline',
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const NamedAction = unionType([ChooseAction, AssignAction, SendAction, ForwardToAction, AfterAction, CancelAction, DoneAction, EscalateAction, LogAction, PureAction, RaiseAction, RespondAction, SendUpdateAction, StartAction, StopAction, SendParentAction]);
const BasicAction = unionType([ActionAsFunctionExpression, ActionAsString, ActionAsIdentifier, ActionAsNode]);
maybeArrayOf(BasicAction);
const MaybeArrayOfActions = maybeArrayOf(unionType([NamedAction, BasicAction]));

const MachineOptionsObject = objectTypeWithKnownKeys({
  actions: objectOf(unionType([ChooseAction, AnyNode])),
  services: objectOf(AnyNode),
  guards: objectOf(AnyNode),
  delays: objectOf(AnyNode),
  devTools: BooleanLiteral
});
const MachineOptions = maybeTsAsExpression(maybeIdentifierTo(MachineOptionsObject));

const Context = AnyNode;

const HistoryAsString = createParser({
  babelMatcher: t__namespace.isStringLiteral,
  parseNode: node => {
    return {
      node,
      value: node.value
    };
  }
});
const HistoryAsBoolean = createParser({
  babelMatcher: t__namespace.isBooleanLiteral,
  parseNode: node => {
    return {
      node,
      value: node.value
    };
  }
});
const History = unionType([HistoryAsString, HistoryAsBoolean]);

const TransitionTarget = maybeArrayOf(unionType([StringLiteral, TemplateLiteral]));
const TransitionObject = objectTypeWithKnownKeys({
  target: TransitionTarget,
  actions: MaybeArrayOfActions,
  cond: Cond,
  description: unionType([StringLiteral, TemplateLiteral])
});
const TransitionConfigOrTargetLiteral = unionType([TransitionObject, wrapParserResult(TransitionTarget, targets => {
  return {
    target: targets,
    node: targets[0].node
  };
})]);
const MaybeTransitionArray = maybeArrayOf(TransitionConfigOrTargetLiteral);

const InvokeSrcFunctionExpression = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: isFunctionOrArrowFunctionExpression,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      value: id,
      node,
      declarationType: 'inline',
      inlineDeclarationId: id
    };
  }
})));
const InvokeSrcNode = createParser({
  babelMatcher: t__namespace.isNode,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      value: id,
      node,
      declarationType: 'unknown',
      inlineDeclarationId: id
    };
  }
});
const InvokeSrcStringLiteral = createParser({
  babelMatcher: t__namespace.isStringLiteral,
  parseNode: (node, context) => ({
    value: node.value,
    node,
    declarationType: 'named',
    inlineDeclarationId: context.getNodeHash(node)
  })
});
const InvokeSrcIdentifier = createParser({
  babelMatcher: t__namespace.isIdentifier,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      value: id,
      node,
      declarationType: 'identifier',
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
});
const InvokeSrc = unionType([InvokeSrcStringLiteral, InvokeSrcFunctionExpression, InvokeSrcIdentifier, InvokeSrcNode]);
const InvokeConfigObject = objectTypeWithKnownKeys({
  id: StringLiteral,
  src: InvokeSrc,
  onDone: MaybeTransitionArray,
  onError: MaybeTransitionArray,
  autoForward: BooleanLiteral,
  forward: BooleanLiteral
});
const Invoke = maybeArrayOf(InvokeConfigObject);

const MetaDescription = unionType([StringLiteral, TemplateLiteral]);
const StateMeta = objectTypeWithKnownKeys({
  description: MetaDescription
});

const Schema = objectTypeWithKnownKeys({
  context: AnyNode,
  events: AnyNode,
  services: AnyNode
});

const TsTypes = unionType([BooleanLiteral, AnyNode]);

const On = objectOf(MaybeTransitionArray);
const After = objectOf(MaybeTransitionArray);
const Tags = maybeArrayOf(StringLiteral);
const StateNodeObject = objectTypeWithKnownKeys(() => ({
  id: StringLiteral,
  initial: StringLiteral,
  type: StringLiteral,
  history: History,
  entry: MaybeArrayOfActions,
  exit: MaybeArrayOfActions,
  onEntry: MaybeArrayOfActions,
  onExit: MaybeArrayOfActions,
  invoke: Invoke,
  always: MaybeTransitionArray,
  onDone: MaybeTransitionArray,
  after: After,
  on: On,
  tags: Tags,
  states: objectOf(StateNodeObject),
  meta: StateMeta,
  data: AnyNode,
  parallel: BooleanLiteral,
  description: unionType([StringLiteral, TemplateLiteral]),
  activities: AnyNode,
  // those should only be allowed at the root level
  tsTypes: TsTypes,
  schema: Schema,
  context: Context,
  preserveActionOrder: BooleanLiteral,
  predictableActionArguments: BooleanLiteral,
  strict: BooleanLiteral,
  version: AnyNode,
  delimiter: StringLiteral,
  key: StringLiteral
}));
const StateNode = StateNodeObject;

const TSTypeParameterInstantiation = parser => createParser({
  babelMatcher: t__namespace.isTSTypeParameterInstantiation,
  parseNode: (node, context) => {
    return {
      node,
      params: node.params.map(param => parser.parse(param, context))
    };
  }
});
const TSType = createParser({
  babelMatcher: t__namespace.isTSType,
  parseNode: node => {
    return {
      node
    };
  }
});
const AnyTypeParameterList = TSTypeParameterInstantiation(TSType);

const ALLOWED_CALL_EXPRESSION_NAMES$1 = ['createMachine', 'Machine', 'createTestMachine'];
const MachineCallExpression = createParser({
  babelMatcher: t__namespace.isCallExpression,
  parseNode: (node, context) => {
    if (t__namespace.isMemberExpression(node.callee) && t__namespace.isIdentifier(node.callee.property) && ALLOWED_CALL_EXPRESSION_NAMES$1.includes(node.callee.property.name)) {
      return {
        callee: node.callee,
        calleeName: node.callee.property.name,
        definition: StateNode.parse(node.arguments[0], context),
        options: MachineOptions.parse(node.arguments[1], context),
        isMemberExpression: true,
        typeArguments: AnyTypeParameterList.parse(node.typeParameters, context),
        node
      };
    }

    if (t__namespace.isIdentifier(node.callee) && ALLOWED_CALL_EXPRESSION_NAMES$1.includes(node.callee.name)) {
      return {
        callee: node.callee,
        calleeName: node.callee.name,
        definition: StateNode.parse(node.arguments[0], context),
        options: MachineOptions.parse(node.arguments[1], context),
        isMemberExpression: false,
        typeArguments: AnyTypeParameterList.parse(node.typeParameters, context),
        node
      };
    }
  }
});

const getMachineNodesFromFile = fileContent => {
  const file = parser.parse(fileContent, {
    sourceType: 'module',
    plugins: ['typescript', 'jsx', ['decorators', {
      decoratorsBeforeExport: false
    }]],
    // required by recast
    tokens: true
  });
  const machineNodes = [];
  traverse__default['default'](file, {
    CallExpression(path) {
      const node = path.node;

      if (t__namespace.isMemberExpression(node.callee) && t__namespace.isIdentifier(node.callee.property) && ALLOWED_CALL_EXPRESSION_NAMES$1.includes(node.callee.property.name)) {
        machineNodes.push(node);
      }

      if (t__namespace.isIdentifier(node.callee) && ALLOWED_CALL_EXPRESSION_NAMES$1.includes(node.callee.name)) {
        machineNodes.push(node);
      }
    }

  });
  return {
    file,
    machineNodes
  };
};

class RecordOfArrays {
  map = {};
  add = (key, value) => {
    if (!this.map[key]) {
      this.map[key] = [];
    }

    this.map[key].push(value);
  };
  toObject = () => this.map;
}

const parseStateNode = (astResult, opts) => {
  var _astResult$meta;

  const config = {};

  if (astResult !== null && astResult !== void 0 && astResult.id) {
    config.id = astResult.id.value;
  }

  if (astResult !== null && astResult !== void 0 && astResult.initial) {
    config.initial = astResult.initial.value;
  }

  if (astResult !== null && astResult !== void 0 && astResult.type) {
    config.type = astResult.type.value;
  }

  if (astResult.entry) {
    config.entry = getActionConfig(astResult.entry, opts);
  }

  if (astResult.onEntry) {
    config.onEntry = getActionConfig(astResult.onEntry, opts);
  }

  if (astResult.exit) {
    config.exit = getActionConfig(astResult.exit, opts);
  }

  if (astResult.onExit) {
    config.onExit = getActionConfig(astResult.onExit, opts);
  }

  if (astResult.tags) {
    const tags = astResult.tags.map(tag => tag.value);

    if (tags.length === 1) {
      config.tags = tags[0];
    } else {
      config.tags = tags;
    }
  }

  if (astResult.on) {
    config.on = {};
    astResult.on.properties.forEach(onProperty => {
      config.on[onProperty.key] = getTransitions(onProperty.result, opts);
    });
  }

  if (astResult.after) {
    config.after = {};
    astResult.after.properties.forEach(afterProperty => {
      config.after[afterProperty.key] = getTransitions(afterProperty.result, opts);
    });
  }

  if (astResult.history) {
    config.history = astResult.history.value;
  }

  if (astResult.states) {
    const states = {};
    astResult.states.properties.forEach(state => {
      states[state.key] = parseStateNode(state.result, opts);
    });
    config.states = states;
  }

  if (astResult.always) {
    config.always = getTransitions(astResult.always, opts);
  }

  if ((_astResult$meta = astResult.meta) !== null && _astResult$meta !== void 0 && _astResult$meta.description) {
    config.meta = {
      description: astResult.meta.description.value
    };
  }

  if (astResult.onDone) {
    config.onDone = getTransitions(astResult.onDone, opts);
  }

  if (astResult.description) {
    config.description = astResult.description.value;
  }

  if (astResult.invoke) {
    const invokes = [];
    astResult.invoke.forEach(invoke => {
      if (!invoke.src) {
        return;
      }

      let src;

      switch (true) {
        case invoke.src.declarationType === 'named':
          src = invoke.src.value;
          break;

        case opts === null || opts === void 0 ? void 0 : opts.anonymizeInlineImplementations:
          src = 'anonymous';

        case opts === null || opts === void 0 ? void 0 : opts.hashInlineImplementations:
          src = invoke.src.inlineDeclarationId;
      }

      const toPush = {
        src: src || (() => () => {})
      };

      if (invoke.id) {
        toPush.id = invoke.id.value;
      }

      if (invoke.autoForward) {
        toPush.autoForward = invoke.autoForward.value;
      }

      if (invoke.forward) {
        toPush.forward = invoke.forward.value;
      }

      if (invoke.onDone) {
        toPush.onDone = getTransitions(invoke.onDone, opts);
      }

      if (invoke.onError) {
        toPush.onError = getTransitions(invoke.onError, opts);
      }

      invokes.push(toPush);
    });

    if (invokes.length === 1) {
      config.invoke = invokes[0];
    } else {
      config.invoke = invokes;
    }
  }

  return config;
};

const toMachineConfig = (result, opts) => {
  if (!(result !== null && result !== void 0 && result.definition)) return undefined;
  return parseStateNode(result === null || result === void 0 ? void 0 : result.definition, opts);
};
const getActionConfig = (astActions, opts) => {
  const actions = [];
  astActions === null || astActions === void 0 ? void 0 : astActions.forEach(action => {
    switch (true) {
      case action.declarationType === 'named':
        actions.push(action.name);
        return;

      case opts === null || opts === void 0 ? void 0 : opts.anonymizeInlineImplementations:
        actions.push({
          type: 'anonymous'
        });
        return;

      case opts === null || opts === void 0 ? void 0 : opts.hashInlineImplementations:
        actions.push({
          type: action.inlineDeclarationId
        });
        return;

      case opts === null || opts === void 0 ? void 0 : opts.stringifyInlineImplementations:
        actions.push(opts.fileContent.slice(action.node.start, action.node.end));
        return;

      case !!action.chooseConditions:
        actions.push({
          type: 'xstate.choose',
          conds: action.chooseConditions.map(condition => {
            const cond = getCondition(condition.conditionNode, opts);
            return { ...(cond && {
                cond
              }),
              actions: getActionConfig(condition.actionNodes, opts)
            };
          })
        });
        return;
    }
  });

  if (actions.length === 1) {
    return actions[0];
  }

  return actions;
};

const getCondition = (condNode, opts) => {
  if (!condNode) {
    return;
  }

  switch (true) {
    case condNode.declarationType === 'named':
      return condNode.name;

    case opts === null || opts === void 0 ? void 0 : opts.anonymizeInlineImplementations:
      return 'anonymous';

    case opts === null || opts === void 0 ? void 0 : opts.hashInlineImplementations:
      return condNode.inlineDeclarationId;
  }
};

const getTransitions = (astTransitions, opts) => {
  const transitions = [];
  astTransitions === null || astTransitions === void 0 ? void 0 : astTransitions.forEach(transition => {
    var _transition$target;

    const toPush = {};

    if (transition !== null && transition !== void 0 && transition.target && (transition === null || transition === void 0 ? void 0 : (_transition$target = transition.target) === null || _transition$target === void 0 ? void 0 : _transition$target.length) > 0) {
      if (transition.target.length === 1) {
        toPush.target = transition === null || transition === void 0 ? void 0 : transition.target[0].value;
      } else {
        toPush.target = transition === null || transition === void 0 ? void 0 : transition.target.map(target => target.value);
      }
    }

    const cond = getCondition(transition === null || transition === void 0 ? void 0 : transition.cond, opts);

    if (cond) {
      toPush.cond = cond;
    }

    if (transition !== null && transition !== void 0 && transition.actions) {
      toPush.actions = getActionConfig(transition.actions, opts);
    }

    if (transition !== null && transition !== void 0 && transition.description) {
      toPush.description = transition === null || transition === void 0 ? void 0 : transition.description.value;
    }

    transitions.push(toPush);
  });

  if (transitions.length === 1) {
    return transitions[0];
  }

  return transitions;
};

function last(arr) {
  return arr[arr.length - 1];
}

const DEFAULT_ROOT_ID = '(machine)';
const b = recast__namespace.types.builders;
const n = recast__namespace.types.namedTypes;

/**
 * Matches '@xstate-layout awdh123jbawdjhbawd'
 */
const layoutRegex = /@xstate-layout [^\s]{1,}/;

const getLayoutString = commentString => {
  var _commentString$match;

  const result = (_commentString$match = commentString.match(layoutRegex)) === null || _commentString$match === void 0 ? void 0 : _commentString$match[0];
  return result === null || result === void 0 ? void 0 : result.slice(`@xstate-layout `.length);
};
/**
 * Gives some helpers to the user of the lib
 */


class MachineExtractResult {
  _idMap = new Map();

  constructor(props) {
    this.machineCallResult = props.machineCallResult;
    this._fileAst = props.fileAst;
    this._fileContent = props.fileContent;
    this.stateNodes = this._getAllStateNodes();
  }

  _getAllStateNodes = () => {
    this._idMap = new Map([// this is the default for the root
    // if we find the explicitly defined ID for the root then this will be overriden
    [DEFAULT_ROOT_ID, []]]);
    const nodes = [];

    const getSubNodes = (definition, path) => {
      var _definition$states;

      if (!definition) {
        return;
      }

      nodes.push({
        ast: definition,
        path
      });

      if (definition.id) {
        this._idMap.set(definition.id.value, path);
      }

      (_definition$states = definition.states) === null || _definition$states === void 0 ? void 0 : _definition$states.properties.forEach(stateNode => {
        getSubNodes(stateNode.result, [...path, stateNode.key]);
      });
    };

    getSubNodes(this.machineCallResult.definition, []);
    return nodes;
  };
  getIsIgnored = () => {
    var _this$machineCallResu;

    if (!((_this$machineCallResu = this.machineCallResult.callee) !== null && _this$machineCallResu !== void 0 && _this$machineCallResu.loc)) return false;
    const isIgnored = (this._fileAst.comments || []).some(comment => {
      if (!comment.value.includes('xstate-ignore-next-line')) {
        return false;
      }

      return comment.loc.end.line === this.machineCallResult.callee.loc.start.line - 1;
    });
    return isIgnored;
  };
  getChooseActionsToAddToOptions = () => {
    const actions$1 = {};
    const chooseActions = this.getChooseActionsInOptions();
    chooseActions.forEach(action => {
      if (action.node.chooseConditions) {
        actions$1[action.node.name] = actions.choose(action.node.chooseConditions.map(chooseCondition => ({
          actions: chooseCondition.actionNodes.map(action => action.name),
          cond: chooseCondition.condition.cond
        })));
      }
    });
    return actions$1;
  };
  getChooseActionsInOptions = () => {
    var _this$machineCallResu2, _this$machineCallResu3;

    const chooseActions = [];
    const allActionsInConfig = this.getAllActionsInConfig();
    (_this$machineCallResu2 = this.machineCallResult.options) === null || _this$machineCallResu2 === void 0 ? void 0 : (_this$machineCallResu3 = _this$machineCallResu2.actions) === null || _this$machineCallResu3 === void 0 ? void 0 : _this$machineCallResu3.properties.forEach(actionProperty => {
      if (actionProperty.result && 'action' in actionProperty.result && actionProperty.result.chooseConditions) {
        const actionInConfig = allActionsInConfig.find(a => a.node.name === actionProperty.key);

        if (actionInConfig) {
          chooseActions.push({
            node: Object.assign(actionProperty.result, {
              /**
               * Give it the name of the action in the config
               */
              name: actionInConfig.node.name
            }),
            statePath: actionInConfig.statePath
          });
        }
      }
    });
    return chooseActions;
  };
  /**
   * Returns the raw value of a comment marked with @xstate-layout.
   *
   * For instance: '@xstate-layout 1234' will return '1234'
   */

  getLayoutComment = () => {
    var _this$machineCallResu4, _this$machineCallResu5;

    if (!((_this$machineCallResu4 = this.machineCallResult.callee) !== null && _this$machineCallResu4 !== void 0 && _this$machineCallResu4.loc)) return undefined;
    const definitionNode = (_this$machineCallResu5 = this.machineCallResult.definition) === null || _this$machineCallResu5 === void 0 ? void 0 : _this$machineCallResu5.node;

    if (definitionNode && t__namespace.isObjectExpression(definitionNode)) {
      var _definitionNode$inner;

      const innerComment = (_definitionNode$inner = definitionNode.innerComments) === null || _definitionNode$inner === void 0 ? void 0 : _definitionNode$inner.find(({
        value
      }) => !!getLayoutString(value));

      if (innerComment) {
        return {
          type: 'inner',
          value: getLayoutString(innerComment.value),
          comment: {
            type: 'xstate-layout',
            node: innerComment
          }
        };
      }

      const firstProp = definitionNode.properties[0];

      if (firstProp) {
        var _firstProp$leadingCom;

        const leadingComment = (_firstProp$leadingCom = firstProp.leadingComments) === null || _firstProp$leadingCom === void 0 ? void 0 : _firstProp$leadingCom.find(({
          value
        }) => !!getLayoutString(value));

        if (leadingComment) {
          return {
            type: 'inner',
            value: getLayoutString(leadingComment.value),
            comment: {
              type: 'xstate-layout',
              node: leadingComment
            }
          };
        }
      }
    }

    const layoutComment = (this._fileAst.comments || []).find(comment => {
      if (!comment.value.includes('xstate-layout')) {
        return false;
      }

      return comment.loc.end.line === this.machineCallResult.callee.loc.start.line - 1;
    });
    if (!layoutComment) return undefined;
    const comment = layoutComment.value;
    const value = getLayoutString(comment);
    if (!value) return undefined;
    return {
      type: 'outer',
      comment: {
        type: 'xstate-layout',
        node: layoutComment
      },
      value
    };
  };
  getTransitions = () => {
    const targets = [];
    this.stateNodes.forEach(stateNode => {
      var _stateNode$ast$on, _stateNode$ast$after, _stateNode$ast$onDone, _stateNode$ast$invoke, _stateNode$ast$always;

      (_stateNode$ast$on = stateNode.ast.on) === null || _stateNode$ast$on === void 0 ? void 0 : _stateNode$ast$on.properties.forEach(on => {
        on.result.forEach((transition, index) => {
          targets.push({
            config: transition,
            fromPath: stateNode.path,
            transitionPath: ['on', on.key, index]
          });
        });
      });
      (_stateNode$ast$after = stateNode.ast.after) === null || _stateNode$ast$after === void 0 ? void 0 : _stateNode$ast$after.properties.forEach(after => {
        after.result.forEach((transition, index) => {
          targets.push({
            config: transition,
            fromPath: stateNode.path,
            transitionPath: ['after', after.key, index]
          });
        });
      });
      (_stateNode$ast$onDone = stateNode.ast.onDone) === null || _stateNode$ast$onDone === void 0 ? void 0 : _stateNode$ast$onDone.forEach((transition, index) => {
        targets.push({
          config: transition,
          fromPath: stateNode.path,
          transitionPath: ['onDone', index]
        });
      });
      (_stateNode$ast$invoke = stateNode.ast.invoke) === null || _stateNode$ast$invoke === void 0 ? void 0 : _stateNode$ast$invoke.forEach((invoke, invokeIndex) => {
        var _invoke$onDone, _invoke$onError;

        (_invoke$onDone = invoke.onDone) === null || _invoke$onDone === void 0 ? void 0 : _invoke$onDone.forEach((transition, index) => {
          targets.push({
            config: transition,
            fromPath: stateNode.path,
            transitionPath: ['invoke', invokeIndex, 'onDone', index]
          });
        });
        (_invoke$onError = invoke.onError) === null || _invoke$onError === void 0 ? void 0 : _invoke$onError.forEach((transition, index) => {
          targets.push({
            config: transition,
            fromPath: stateNode.path,
            transitionPath: ['invoke', invokeIndex, 'onError', index]
          });
        });
      });
      (_stateNode$ast$always = stateNode.ast.always) === null || _stateNode$ast$always === void 0 ? void 0 : _stateNode$ast$always.forEach((transition, index) => {
        targets.push({
          config: transition,
          fromPath: stateNode.path,
          transitionPath: ['always', index]
        });
      });
    });
    return targets;
  };
  getTransitionTargets = () => {
    return this.getTransitions().map(transition => {
      var _transition$config;

      if (!((_transition$config = transition.config) !== null && _transition$config !== void 0 && _transition$config.target)) {
        return;
      }

      return {
        target: transition.config.target,
        fromPath: transition.fromPath,
        transitionPath: transition.transitionPath,
        targetPath: transition.config.target.map(target => {
          if (target.value.startsWith('#')) {
            const targetedId = target.value.split('.')[0].slice(1);

            const idPath = this._idMap.get(targetedId);

            if (!idPath) {
              return;
            }

            return idPath.concat(target.value.split('.').slice(1));
          }

          if (target.value.startsWith('.')) {
            return transition.fromPath.concat(target.value.slice(1).split('.'));
          }

          return transition.fromPath.slice(0, -1).concat(target.value.split('.'));
        })
      };
    }).filter(transition => Boolean(transition));
  };
  getStateNodeByPath = path => {
    return this.stateNodes.find(node => {
      return node.path.join('') === path.join('');
    });
  };
  getAllStateNodes = () => this.stateNodes;
  toConfig = opts => {
    return toMachineConfig(this.machineCallResult, { ...opts,
      fileContent: this._fileContent
    });
  };
  getAllConds = (declarationTypes = ['identifier', 'inline', 'unknown', 'named']) => {
    const conds = [];
    this.getTransitions().forEach(transition => {
      var _transition$config$co, _transition$config$co2;

      if ((_transition$config$co = transition.config.cond) !== null && _transition$config$co !== void 0 && _transition$config$co.declarationType && declarationTypes.includes((_transition$config$co2 = transition.config.cond) === null || _transition$config$co2 === void 0 ? void 0 : _transition$config$co2.declarationType)) {
        conds.push({
          name: transition.config.cond.name,
          node: transition.config.cond.node,
          cond: transition.config.cond.cond,
          statePath: transition.fromPath,
          inlineDeclarationId: transition.config.cond.inlineDeclarationId
        });
      }
    });
    this.getChooseActionsInOptions().concat(this.getAllActionsInConfig()).forEach(action => {
      var _action$node$chooseCo;

      (_action$node$chooseCo = action.node.chooseConditions) === null || _action$node$chooseCo === void 0 ? void 0 : _action$node$chooseCo.forEach(chooseCondition => {
        var _chooseCondition$cond, _chooseCondition$cond2;

        if ((_chooseCondition$cond = chooseCondition.conditionNode) !== null && _chooseCondition$cond !== void 0 && _chooseCondition$cond.declarationType && declarationTypes.includes((_chooseCondition$cond2 = chooseCondition.conditionNode) === null || _chooseCondition$cond2 === void 0 ? void 0 : _chooseCondition$cond2.declarationType)) {
          conds.push({
            name: chooseCondition.conditionNode.name,
            node: chooseCondition.conditionNode.node,
            cond: chooseCondition.conditionNode.cond,
            statePath: action.statePath,
            inlineDeclarationId: chooseCondition.conditionNode.inlineDeclarationId
          });
        }
      });
    });
    return conds;
  };
  getAllActionsInConfig = () => {
    const actions = [];

    const addAction = (action, statePath) => {
      var _action$chooseConditi;

      actions.push({
        node: action,
        statePath
      });
      (_action$chooseConditi = action.chooseConditions) === null || _action$chooseConditi === void 0 ? void 0 : _action$chooseConditi.forEach(chooseCondition => {
        chooseCondition.actionNodes.forEach(action => {
          addAction(action, statePath);
        });
      });
    };

    this.getTransitions().forEach(transition => {
      var _transition$config2, _transition$config2$a;

      (_transition$config2 = transition.config) === null || _transition$config2 === void 0 ? void 0 : (_transition$config2$a = _transition$config2.actions) === null || _transition$config2$a === void 0 ? void 0 : _transition$config2$a.forEach(action => addAction(action, transition.fromPath));
    });
    this.getAllStateNodes().forEach(node => {
      var _node$ast$entry, _node$ast$onEntry, _node$ast$exit, _node$ast$onExit;

      (_node$ast$entry = node.ast.entry) === null || _node$ast$entry === void 0 ? void 0 : _node$ast$entry.forEach(action => {
        addAction(action, node.path);
      });
      (_node$ast$onEntry = node.ast.onEntry) === null || _node$ast$onEntry === void 0 ? void 0 : _node$ast$onEntry.forEach(action => {
        addAction(action, node.path);
      });
      (_node$ast$exit = node.ast.exit) === null || _node$ast$exit === void 0 ? void 0 : _node$ast$exit.forEach(action => {
        addAction(action, node.path);
      });
      (_node$ast$onExit = node.ast.onExit) === null || _node$ast$onExit === void 0 ? void 0 : _node$ast$onExit.forEach(action => {
        addAction(action, node.path);
      });
    });
    return actions;
  };
  getAllActions = (declarationTypes = ['identifier', 'inline', 'unknown', 'named']) => {
    const actions = [];

    const addActionIfHasName = (action, statePath) => {
      if (action && declarationTypes.includes(action.declarationType)) {
        actions.push({
          name: action.name,
          node: action.node,
          action: action.action,
          statePath,
          chooseConditions: action.chooseConditions,
          inlineDeclarationId: action.inlineDeclarationId
        });
      }
    };

    this.getAllActionsInConfig().forEach(action => {
      addActionIfHasName(action.node, action.statePath);
    });
    this.getChooseActionsInOptions().forEach(action => {
      var _action$node$chooseCo2;

      (_action$node$chooseCo2 = action.node.chooseConditions) === null || _action$node$chooseCo2 === void 0 ? void 0 : _action$node$chooseCo2.forEach(chooseCondition => {
        chooseCondition.actionNodes.forEach(chooseAction => {
          addActionIfHasName(chooseAction, action.statePath);
        });
      });
    });
    return actions;
  };
  getAllServices = (declarationTypes = ['identifier', 'inline', 'unknown', 'named']) => {
    const services = [];
    this.stateNodes.map(stateNode => {
      var _stateNode$ast$invoke2;

      (_stateNode$ast$invoke2 = stateNode.ast.invoke) === null || _stateNode$ast$invoke2 === void 0 ? void 0 : _stateNode$ast$invoke2.forEach(invoke => {
        var _invoke$src, _invoke$src2, _invoke$src3;

        const invokeSrc = typeof ((_invoke$src = invoke.src) === null || _invoke$src === void 0 ? void 0 : _invoke$src.value) === 'string' ? invoke.src.value : undefined;

        if ((_invoke$src2 = invoke.src) !== null && _invoke$src2 !== void 0 && _invoke$src2.declarationType && declarationTypes.includes((_invoke$src3 = invoke.src) === null || _invoke$src3 === void 0 ? void 0 : _invoke$src3.declarationType)) {
          var _invoke$src4, _invoke$id, _invoke$src5, _invoke$src6;

          services.push({
            src: invokeSrc ?? ((_invoke$src4 = invoke.src) === null || _invoke$src4 === void 0 ? void 0 : _invoke$src4.inlineDeclarationId),
            id: (_invoke$id = invoke.id) === null || _invoke$id === void 0 ? void 0 : _invoke$id.value,
            node: invoke.node,
            statePath: stateNode.path,
            srcNode: (_invoke$src5 = invoke.src) === null || _invoke$src5 === void 0 ? void 0 : _invoke$src5.node,
            inlineDeclarationId: (_invoke$src6 = invoke.src) === null || _invoke$src6 === void 0 ? void 0 : _invoke$src6.inlineDeclarationId
          });
        }
      });
    });
    return services;
  };
  getAllNamedDelays = () => {
    const delays = new RecordOfArrays();
    this.stateNodes.map(stateNode => {
      var _stateNode$ast$after2;

      (_stateNode$ast$after2 = stateNode.ast.after) === null || _stateNode$ast$after2 === void 0 ? void 0 : _stateNode$ast$after2.properties.forEach(property => {
        if (t__namespace.isIdentifier(property.keyNode)) {
          const key = property.key;
          delays.add(key, {
            node: property.keyNode,
            name: key,
            statePath: stateNode.path
          });
        }
      });
    });
    return delays.toObject();
  };
  getActionImplementation = name => {
    var _this$machineCallResu6, _this$machineCallResu7;

    const node = (_this$machineCallResu6 = this.machineCallResult.options) === null || _this$machineCallResu6 === void 0 ? void 0 : (_this$machineCallResu7 = _this$machineCallResu6.actions) === null || _this$machineCallResu7 === void 0 ? void 0 : _this$machineCallResu7.properties.find(property => {
      return property.key === name;
    });
    return node;
  };
  getServiceImplementation = name => {
    var _this$machineCallResu8, _this$machineCallResu9;

    const node = (_this$machineCallResu8 = this.machineCallResult.options) === null || _this$machineCallResu8 === void 0 ? void 0 : (_this$machineCallResu9 = _this$machineCallResu8.services) === null || _this$machineCallResu9 === void 0 ? void 0 : _this$machineCallResu9.properties.find(property => {
      return property.key === name;
    });
    return node;
  };
  getGuardImplementation = name => {
    var _this$machineCallResu10, _this$machineCallResu11;

    const node = (_this$machineCallResu10 = this.machineCallResult.options) === null || _this$machineCallResu10 === void 0 ? void 0 : (_this$machineCallResu11 = _this$machineCallResu10.guards) === null || _this$machineCallResu11 === void 0 ? void 0 : _this$machineCallResu11.properties.find(property => {
      return property.key === name;
    });
    return node;
  };

  modify(edits) {
    // we need to read it before calling `recast.parse` as that mutates the AST and removes comments and sometimes also locations
    const existingLayoutComment = this.getLayoutComment();
    const existingMachineNodeLoc = this.machineCallResult.node.loc; // this ain't ideal because Recast mutates the input AST
    // so there is a risk that modifying multiple machines in a single file would lead to problems
    // however, we never modify multiple machines based on the same file content so this is somewhat safe
    // each modification updates the AST, that is printed and the file is re-parsed, so the next modification sees the next AST

    const ast = recast__namespace.parse(this._fileContent, {
      parser: {
        // this is a slight hack to defer the work done by `recast.parse`
        // we don't need to re-parse the file though, as we already have the AST
        parse: () => this._fileAst
      }
    });
    const recastDefinitionNode = findRecastDefinitionNode(ast, this.machineCallResult.definition.node);
    const deleted = [];
    let layoutEdit;

    for (const edit of edits) {
      switch (edit.type) {
        case 'add_state':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);
            const statesProp = findObjectProperty(stateObj, 'states');

            if (statesProp) {
              const unwrapped = unwrapSimplePropValue(statesProp);
              n.ObjectExpression.assert(unwrapped);
              setProperty(unwrapped, edit.name, toObjectExpression({}));
            } else {
              setProperty(stateObj, 'states', toObjectExpression({
                [edit.name]: {}
              }));
            }

            break;
          }

        case 'remove_state':
          {
            this.getTransitionTargets().forEach(({
              target,
              targetPath,
              fromPath,
              transitionPath
            }) => {
              target.forEach((_, index) => {
                if (!targetPath[index] || !arePathsEqual(targetPath[index].slice(0, edit.path.length), edit.path)) {
                  return;
                }

                const parentObj = getStateObjectByPath(recastDefinitionNode, fromPath);
                removeTransitionAtPath(parentObj, transitionPath);
              });
            });
            const removed = removeState(recastDefinitionNode, edit.path);
            deleted.push({
              type: 'state',
              statePath: edit.path,
              state: removed
            });
            break;
          }

        case 'rename_state':
          {
            const stateProp = getStatePropByPath(recastDefinitionNode, edit.path);
            n.ObjectProperty.assert(stateProp);
            const oldName = n.Identifier.check(stateProp.key) ? stateProp.key.name : n.StringLiteral.check(stateProp.key) ? stateProp.key.value : null;

            if (oldName === null) {
              throw new Error('Could not find the old name of the state');
            }

            const initialProp = getPropByPath(recastDefinitionNode, [...edit.path.slice(0, -1).flatMap(p => ['states', p]), 'initial']);

            if (initialProp) {
              const unwrapped = unwrapSimplePropValue(initialProp);

              if (unwrapped && getSimpleStringValue(unwrapped) === oldName) {
                setPropertyValue(initialProp, b.stringLiteral(edit.name));
              }
            }

            const targetableAncestorIds = collectAncestorIds(recastDefinitionNode, edit.path);
            this.getTransitionTargets().forEach(({
              fromPath,
              target,
              transitionPath,
              targetPath
            }) => {
              // TODO: this doesn't support multiple targets, but Studio doesn't support that either
              target.forEach((t, index) => {
                if (t.value.charAt(0) === '#') {
                  if (!targetPath[0] || !t.value.includes('.')) {
                    return;
                  }

                  const targetedId = t.value.split('.')[0].slice(1);

                  if (!targetableAncestorIds.has(targetedId) || !arePathsEqual(targetPath[0].slice(0, edit.path.length), edit.path)) {
                    return;
                  }

                  const idPath = this._idMap.get(targetedId);

                  const segmentedValue = t.value.split('.').slice(1);
                  const affectedSegment = edit.path.length - idPath.length - 1;
                  segmentedValue[affectedSegment] = edit.name;
                  const newValue = `#${targetedId}.${segmentedValue.join('.')}`;
                  updateTargetAtObjectPath(recastDefinitionNode, [...fromPath.flatMap(p => ['states', p]), ...transitionPath], newValue);
                  return;
                }

                if (t.value.charAt(0) === '.') {
                  if (!arePathsEqual(targetPath[index].slice(0, edit.path.length), edit.path)) {
                    return;
                  }

                  const segmentedValue = t.value.slice(1).split('.');
                  const affectedSegment = edit.path.length - fromPath.length - 1;
                  segmentedValue[affectedSegment] = edit.name;
                  const newValue = `.${segmentedValue.join('.')}`;
                  updateTargetAtObjectPath(recastDefinitionNode, [...fromPath.flatMap(p => ['states', p]), ...transitionPath], newValue);
                  return;
                } // root has no siblings so for `fromPath: []` we don't need to check for siblings
                // `[].slice(0, -1)` gives us `[]` back, so while the intention is to check the parent path...
                // for the root we'd just stay at the root


                if (!fromPath.length) {
                  return;
                }

                if (!arePathsEqual(targetPath[index].slice(0, edit.path.length), edit.path)) {
                  return;
                }

                const segmentedValue = t.value.split('.');
                const affectedSegment = edit.path.length - fromPath.length;
                segmentedValue[affectedSegment] = edit.name; // this transition targets a state within the renamed sibling
                // we can't just update the segment to the empty string as that would result in targeting own descendant

                if (edit.name === '') {
                  // TODO: figure out a better solution
                  // we should not rename this key temporarily and rename it back
                  // unfortunately, `getBestTargetDescriptor` relies on the updated key
                  const oldKey = stateProp.key;
                  stateProp.key = safePropertyKey(edit.name);
                  const targetDescriptor = getBestTargetDescriptor(recastDefinitionNode, {
                    sourcePath: fromPath,
                    targetPath: segmentedValue
                  });
                  stateProp.key = oldKey;
                  updateTargetAtObjectPath(recastDefinitionNode, [...fromPath.flatMap(p => ['states', p]), ...transitionPath], targetDescriptor);
                  return;
                }

                const newValue = segmentedValue.join('.');
                updateTargetAtObjectPath(recastDefinitionNode, [...fromPath.flatMap(p => ['states', p]), ...transitionPath], newValue);
                return;
              });
            });
            stateProp.key = safePropertyKey(edit.name);
            break;
          }

        case 'reparent_state':
          {
            if (edit.path.length === 0) {
              throw new Error(`Root state can't be moved.`);
            }

            if (arePathsEqual(edit.path, edit.newParentPath.slice(0, edit.path.length))) {
              throw new Error(`The new parent of a state has to be outside of that state.`);
            }

            const targetRecomputeCandidates = [];

            for (const t of this.getTransitionTargets()) {
              const targetPath = t.targetPath[0];

              if (!targetPath) {
                continue;
              }

              if ( // if source is an ancestor of the reparented state
              t.fromPath.length !== edit.path.length && arePathsEqual(t.fromPath, edit.path.slice(0, t.fromPath.length))) {
                if ( // and it's targeting a state in the reparented state
                arePathsEqual(t.fromPath, targetPath.slice(0, t.fromPath.length)) && // we don't need to touch self-transitions though
                t.fromPath.length !== targetPath.length) {
                  targetRecomputeCandidates.push({
                    sourcePath: t.fromPath,
                    targetPath: [...edit.newParentPath, ...targetPath.slice(targetPath.length - edit.path.length - 1)],
                    transitionPath: t.transitionPath
                  });
                  continue;
                }

                continue;
              }

              if ( // if the source is within the reparented state
              arePathsEqual(edit.path, t.fromPath.slice(0, edit.path.length))) {
                // if the target lies outside of the reparented state
                if (!arePathsEqual(edit.path, targetPath.slice(0, edit.path.length))) {
                  // then we only need to adjust potential sibling targets
                  if (!t.target[0].value.startsWith('#') && !t.target[0].value.startsWith('.')) {
                    targetRecomputeCandidates.push({
                      sourcePath: [...edit.newParentPath, ...t.fromPath.slice(t.fromPath.length - edit.path.length - 1)],
                      targetPath,
                      transitionPath: t.transitionPath
                    });
                    continue;
                  }

                  continue;
                } // if the source and target lies within the reparent state then we can assume that we don't have to adjust the target descriptor
                // unless it's using an ID-based descriptor, other descriptors can't "escape" the reparented state


                if (t.target[0].value.startsWith('#') && // we can also leave alone ID-based targets without dots as the descriptor using only the ID won't need to be adjusted either
                t.target[0].value.includes('.')) {
                  targetRecomputeCandidates.push({
                    sourcePath: [...edit.newParentPath, ...t.fromPath.slice(t.fromPath.length - edit.path.length - 1)],
                    targetPath: [...edit.newParentPath, ...targetPath.slice(targetPath.length - edit.path.length - 2)],
                    transitionPath: t.transitionPath
                  });
                  continue;
                }

                continue;
              } // by now we know that the source has no ancestor<->descendant relationship with the reparented state
              // so we only need to check if the target path lies within the reparent state


              if (arePathsEqual(edit.path, targetPath.slice(0, edit.path.length))) {
                targetRecomputeCandidates.push({
                  sourcePath: t.fromPath,
                  targetPath: [...edit.newParentPath, ...targetPath.slice(targetPath.length - edit.path.length - 1)],
                  transitionPath: t.transitionPath
                });
                continue;
              }
            }

            const state = removeState(recastDefinitionNode, edit.path);
            const newParent = getStateObjectByPath(recastDefinitionNode, edit.newParentPath);
            setProperty(getStatesObjectInState(newParent), last(edit.path), state);
            targetRecomputeCandidates.forEach(candidate => {
              updateTargetAtObjectPath(recastDefinitionNode, [...candidate.sourcePath.flatMap(p => ['states', p]), ...candidate.transitionPath], getBestTargetDescriptor(recastDefinitionNode, candidate));
            });
            const oldParent = getStateObjectByPath(recastDefinitionNode, edit.path.slice(0, -1));
            const initialPropIndex = findObjectPropertyIndex(oldParent, 'initial');

            if (initialPropIndex === -1) {
              break;
            }

            const initialValue = getSimpleStringValue(unwrapSimplePropValue(oldParent.properties[initialPropIndex]));

            if (initialValue === last(edit.path)) {
              removeProperty(oldParent, 'initial');
            }

            break;
          }

        case 'set_initial_state':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);

            if (typeof edit.initialState === 'string') {
              setProperty(stateObj, 'initial', b.stringLiteral(edit.initialState));
            } else {
              removeProperty(stateObj, 'initial');
            }

            break;
          }

        case 'set_state_id':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);

            if (typeof edit.id === 'string') {
              setProperty(stateObj, 'id', b.stringLiteral(edit.id));
            } else {
              removeProperty(stateObj, 'id');
            }

            break;
          }

        case 'set_state_type':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);

            if (edit.stateType === 'normal') {
              removeProperty(stateObj, 'type');
            } else {
              setProperty(stateObj, 'type', b.stringLiteral(edit.stateType));
            }

            if (edit.stateType === 'history') {
              if (edit.history === 'deep') {
                setProperty(stateObj, 'history', b.stringLiteral('deep'));
              } else {
                removeProperty(stateObj, 'history');
              }
            } else {
              removeProperty(stateObj, 'history');
            }

            break;
          }

        case 'add_transition':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.sourcePath);
            const target = getBestTargetDescriptor(recastDefinitionNode, edit);
            const transition = minifyTransitionObjectExpression(toObjectExpression({ ...(edit.guard && {
                cond: edit.guard
              })
            }), { ...(typeof target === 'string' && {
                target
              }),
              ...(target !== null && target !== void 0 && target.startsWith('.') && edit.external ? {
                internal: false
              } : edit.targetPath && arePathsEqual(edit.sourcePath, edit.targetPath) && !edit.external ? {
                internal: true
              } : null)
            });
            insertAtTransitionPath(stateObj, edit.transitionPath, transition);
            break;
          }

        case 'remove_transition':
          {
            const removed = removeTransitionAtPath(getStateObjectByPath(recastDefinitionNode, edit.sourcePath), edit.transitionPath);

            if (!removed) {
              break;
            }

            deleted.push({
              type: 'transition',
              sourcePath: edit.sourcePath,
              transitionPath: edit.transitionPath,
              transition: removed
            });
            break;
          }

        case 'reanchor_transition':
          {
            let sourceObj = getStateObjectByPath(recastDefinitionNode, edit.sourcePath);
            const oldTransition = this.getTransitionTargets().find(t => arePathsEqual(t.fromPath, edit.sourcePath) && arePathsEqual(t.transitionPath, edit.transitionPath)); // TODO: this doesn't handle multiple targets but Studio doesnt either

            const oldTargetPath = (oldTransition === null || oldTransition === void 0 ? void 0 : oldTransition.targetPath[0]) ?? null;
            let newTransitionPath = edit.newTransitionPath || edit.transitionPath;

            if (edit.newSourcePath) {
              const removed = removeTransitionAtPath(sourceObj, edit.transitionPath);

              if (!removed) {
                throw new Error(`Reanchoring requires the transitionPath ([${edit.transitionPath.join(', ')}]) to exist on the source state ([${edit.sourcePath.join(', ')}])`);
              }

              sourceObj = getStateObjectByPath(recastDefinitionNode, edit.newSourcePath);
              newTransitionPath = edit.newTransitionPath || [...edit.transitionPath.slice(0, -1), getIndexForTransitionPathAppendant(sourceObj, edit.transitionPath)];
              insertAtTransitionPath(sourceObj, newTransitionPath, removed);
            }

            const newTargetPath = 'newTargetPath' in edit ? edit.newTargetPath : oldTargetPath;
            const newSourcePath = edit.newSourcePath || edit.sourcePath;
            const transitionProp = getPropByPath(sourceObj, newTransitionPath.slice(0, -1));
            const index = last(newTransitionPath);
            const target = getBestTargetDescriptor(recastDefinitionNode, {
              sourcePath: newSourcePath,
              targetPath: newTargetPath
            });
            const transitionObject = getTransitionAtIndex(unwrapSimplePropValue(transitionProp), index);
            const finalExternal = getTransitionExternalValue({
              source: edit.sourcePath,
              target: oldTargetPath
            }, {
              source: newSourcePath,
              target: newTargetPath
            }, transitionObject); // TODO: this logic could maybe be somehow merged with `updateTransitionAtPathWith`

            const minifiedTransition = minifyTransitionObjectExpression(transitionObject, {
              target,
              internal: !finalExternal
            });

            if (n.ArrayExpression.check(transitionProp.value)) {
              if (transitionProp.value.elements.length === 1) {
                transitionProp.value = minifiedTransition;
                break;
              }

              transitionProp.value.elements[index] = minifiedTransition;
            } else {
              transitionProp.value = minifiedTransition;
            }

            break;
          }

        case 'change_transition_path':
          {
            const sourceObj = getStateObjectByPath(recastDefinitionNode, edit.sourcePath);
            const removed = removeTransitionAtPath(sourceObj, edit.transitionPath);

            if (!removed) {
              throw new Error(`Changing transition path requires the transitionPath ([${edit.transitionPath.join(', ')}]) to exist on the source state ([${edit.sourcePath.join(', ')}])`);
            }

            insertAtTransitionPath(sourceObj, edit.newTransitionPath, removed);
            break;
          }

        case 'mark_transition_as_external':
          {
            const sourceObj = getStateObjectByPath(recastDefinitionNode, edit.sourcePath);
            const transitionProp = getPropByPath(sourceObj, edit.transitionPath.slice(0, -1));
            const index = last(edit.transitionPath);
            const transitionObject = getTransitionAtIndex(unwrapSimplePropValue(transitionProp), index); // TODO: this logic could maybe be somehow merged with `updateTransitionAtPathWith`

            const minifiedTransition = minifyTransitionObjectExpression(transitionObject, {
              internal: !edit.external
            });

            if (n.ArrayExpression.check(transitionProp.value)) {
              if (transitionProp.value.elements.length === 1) {
                transitionProp.value = minifiedTransition;
                break;
              }

              transitionProp.value.elements[index] = minifiedTransition;
            } else {
              transitionProp.value = minifiedTransition;
            }

            break;
          }

        case 'add_action':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);
            insertAtActionPath(stateObj, edit.actionPath, t__namespace.stringLiteral(edit.name));
            break;
          }

        case 'remove_action':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);
            removeAtActionPath(stateObj, edit.actionPath);
            break;
          }

        case 'edit_action':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);
            editAtActionPath(stateObj, edit.actionPath, t__namespace.stringLiteral(edit.name));
            break;
          }

        case 'add_guard':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);
            insertGuardAtTransitionPath(stateObj, edit.transitionPath, t__namespace.stringLiteral(edit.name));
            break;
          }

        case 'remove_guard':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);
            removeGuardFromTransition(stateObj, edit.transitionPath);
            break;
          }

        case 'edit_guard':
          {
            const stateObj = getStateObjectByPath(recastDefinitionNode, edit.path);
            editGuardAtTransitionPath(stateObj, edit.transitionPath, t__namespace.stringLiteral(edit.name));
            break;
          }

        case 'add_invoke':
          {
            insertAtArrayifiableProperty({
              obj: getStateObjectByPath(recastDefinitionNode, edit.path),
              property: 'invoke',
              index: edit.invokeIndex,
              value: toObjectExpression({
                src: edit.source,
                ...(edit.id && {
                  id: edit.id
                })
              })
            });
            break;
          }

        case 'remove_invoke':
          {
            // transitions related to this invoke are already defined in that invoke so it's enough to remove the invoke itself
            removeAtArrayifiableProperty({
              obj: getStateObjectByPath(recastDefinitionNode, edit.path),
              property: 'invoke',
              index: edit.invokeIndex
            });
            break;
          }

        case 'edit_invoke':
          {
            const state = getStateObjectByPath(recastDefinitionNode, edit.path);
            const invokeProp = getPropByPath(state, ['invoke']);
            const unwrapped = unwrapSimplePropValue(invokeProp);

            if (n.ArrayExpression.check(unwrapped)) {
              const invoke = unwrapped.elements[edit.invokeIndex];
              n.ObjectExpression.assert(invoke);
              updateInvoke(invoke, edit);
              break;
            }

            n.ObjectExpression.assert(unwrapped);
            updateInvoke(unwrapped, edit);
            break;
          }

        case 'set_description':
          {
            const state = getStateObjectByPath(recastDefinitionNode, edit.statePath);

            if (!edit.transitionPath) {
              updateDescription(state, edit.description ?? null);
              break;
            }

            const transition = getTransitionObject(state, edit.transitionPath);
            updateDescription(transition, edit.description ?? null);
            updateTransitionAtPathWith(state, edit.transitionPath, transition);
            break;
          }

        case 'update_layout_string':
          if (layoutEdit) {
            throw new Error('Receiving multiple `update_layout_string` edits in a single batch is not supported');
          }

          if (!existingLayoutComment) {
            var _this$machineCallResu12, _definitionNode$prope;

            const definitionNode = (_this$machineCallResu12 = this.machineCallResult.definition) === null || _this$machineCallResu12 === void 0 ? void 0 : _this$machineCallResu12.node;

            if (!t__namespace.isObjectExpression(definitionNode)) {
              const calleePosition = {
                line: this.machineCallResult.callee.loc.start.line - 1,
                column: this.machineCallResult.callee.loc.start.column,
                index: this.machineCallResult.callee.start
              };
              layoutEdit = {
                // this is used as a replace but it could be a simpler~ insertion
                type: 'replace',
                range: [calleePosition, calleePosition],
                newText: `\n/** @xstate-layout ${edit.layoutString} */\n`
              };
              break;
            }

            const indentation = consumeIndentationToNodeAtIndex(this._fileContent, (_definitionNode$prope = definitionNode.properties[0]) === null || _definitionNode$prope === void 0 ? void 0 : _definitionNode$prope.start);
            const insidePosition = {
              line: definitionNode.loc.start.line - 1,
              column: definitionNode.loc.start.column + 1,
              index: definitionNode.start + 1
            };
            layoutEdit = {
              // this is used as a replace but it could be a simpler~ insertion
              type: 'replace',
              range: [insidePosition, insidePosition],
              newText: `\n${indentation}/** @xstate-layout ${edit.layoutString} */`
            };
            break;
          }

          layoutEdit = {
            type: 'replace',
            range: [{
              line: existingLayoutComment.comment.node.loc.start.line - 1,
              column: existingLayoutComment.comment.node.loc.start.column,
              index: existingLayoutComment.comment.node.start
            }, {
              line: existingLayoutComment.comment.node.loc.end.line - 1,
              column: existingLayoutComment.comment.node.loc.end.column,
              index: existingLayoutComment.comment.node.end
            }],
            newText: `/** @xstate-layout ${edit.layoutString} */`
          };
      }
    } // as an extra safety measure we grab `oldRange` before reprinting the `ast`


    const oldRange = [{
      line: this.machineCallResult.definition.node.loc.start.line - 1,
      column: this.machineCallResult.definition.node.loc.start.column,
      index: this.machineCallResult.definition.node.start
    }, {
      line: this.machineCallResult.definition.node.loc.end.line - 1,
      column: this.machineCallResult.definition.node.loc.end.column,
      index: this.machineCallResult.definition.node.end
    }];
    const reprinted = recast__namespace.print(ast).code; // find the matching machine node in the new text of the whole file
    // it's wasteful to parse the whole new file here
    // it's the best way we have right now to keep the formatting intact as much as possible though

    const machineNode = getMachineNodesFromFile(reprinted).machineNodes.find(machineNode => machineNode.loc.start.line === existingMachineNodeLoc.start.line && machineNode.loc.start.column === existingMachineNodeLoc.start.column);
    const configEdit = {
      type: 'replace',
      range: oldRange,
      newText: reprinted.slice(machineNode.arguments[0].start, machineNode.arguments[0].end)
    };
    return {
      layoutEdit,
      configEdit,
      deleted: deleted.length ? deleted : undefined
    };
  }

  restore({
    deleted
  }) {
    // TODO deduplicate pre and post loop stuff
    // this ain't ideal because Recast mutates the input AST
    // so there is a risk that modifying multiple machines in a single file would lead to problems
    // however, we never modify multiple machines based on the same file content so this is somewhat safe
    // each modification updates the AST, that is printed and the file is re-parsed, so the next modification sees the next AST
    const ast = recast__namespace.parse(this._fileContent, {
      parser: {
        // this is a slight hack to defer the work done by `recast.parse`
        // we don't need to re-parse the file though, as we already have the AST
        parse: () => this._fileAst
      }
    });
    const recastDefinitionNode = findRecastDefinitionNode(ast, this.machineCallResult.definition.node);

    for (const entity of [...deleted].reverse()) {
      if (entity.type === 'state') {
        const stateObj = getStateObjectByPath(recastDefinitionNode, entity.statePath.slice(0, -1));
        const statesProp = findObjectProperty(stateObj, 'states');

        if (statesProp) {
          const unwrapped = unwrapSimplePropValue(statesProp);
          n.ObjectExpression.assert(unwrapped);
          setProperty(unwrapped, last(entity.statePath), entity.state);
        } else {
          setProperty(stateObj, 'states', toObjectExpression({
            [last(entity.statePath)]: entity.state
          }));
        }
      } else {
        const sourceObj = getStateObjectByPath(recastDefinitionNode, entity.sourcePath);
        insertAtTransitionPath(sourceObj, entity.transitionPath, entity.transition);
      }
    }

    const oldRange = [{
      line: this.machineCallResult.definition.node.loc.start.line - 1,
      column: this.machineCallResult.definition.node.loc.start.column,
      index: this.machineCallResult.definition.node.start
    }, {
      line: this.machineCallResult.definition.node.loc.end.line - 1,
      column: this.machineCallResult.definition.node.loc.end.column,
      index: this.machineCallResult.definition.node.end
    }];
    const reprinted = recast__namespace.print(ast).code; // find the matching machine node in the new text of the whole file
    // it's wasteful to parse the whole new file here
    // it's the best way we have right now to keep the formatting intact as much as possible though

    const machineNode = getMachineNodesFromFile(reprinted).machineNodes.find(machineNode => machineNode.loc.start.line === this.machineCallResult.node.loc.start.line && machineNode.loc.start.column === this.machineCallResult.node.loc.start.column);
    return {
      configEdit: {
        type: 'replace',
        range: oldRange,
        newText: reprinted.slice(machineNode.arguments[0].start, machineNode.arguments[0].end)
      }
    };
  }

}

function removeProperty(obj, propName) {
  let propIndex = -1; // ensure that duplicate properties are removed

  while ((propIndex = findObjectPropertyIndex(obj, propName)) !== -1) {
    obj.properties.splice(propIndex, 1);
  }
}

function setProperty(obj, propName, value) {
  const prop = findObjectProperty(obj, propName);

  if (prop) {
    prop.value = value;
    return;
  }

  obj.properties.push(b.objectProperty(safePropertyKey(propName), value));
}

function updateDescription(obj, description) {
  if (typeof description !== 'string') {
    removeProperty(obj, 'description');
    return;
  }

  setProperty(obj, 'description', t__namespace.templateLiteral([t__namespace.templateElement({
    raw: description
  })], []));
}

function updateInvoke(invoke, data) {
  if (typeof data.id === 'string') {
    const idProp = findObjectProperty(invoke, 'id');

    if (idProp) {
      idProp.value = b.stringLiteral(data.id);
    } else {
      invoke.properties.push(b.objectProperty(b.identifier('id'), b.stringLiteral(data.id)));
    }
  } else if ('id' in data) {
    removeProperty(invoke, 'id');
  }

  if (typeof data.source === 'string') {
    const srcProp = findObjectProperty(invoke, 'src');
    srcProp.value = updateItemType(unwrapSimplePropValue(srcProp), b.stringLiteral(data.source));
  }
}

function updateTargetAtObjectPath(obj, objPath, newTarget) {
  const prop = getPropByPath(obj, objPath.slice(0, -1));

  if (n.ArrayExpression.check(prop.value)) {
    const index = last(objPath);
    const element = prop.value.elements[index];

    if (!n.ObjectExpression.check(element)) {
      prop.value.elements.splice(index, 1, b.stringLiteral(newTarget));
    } else {
      setProperty(element, 'target', b.stringLiteral(newTarget));
    }
  } else if (!n.ObjectExpression.check(prop.value)) {
    setPropertyValue(prop, b.stringLiteral(newTarget));
  } else {
    setProperty(prop.value, 'target', b.stringLiteral(newTarget));
  }
}

function getPropertyKey(prop) {
  if (n.Identifier.check(prop.key)) {
    return prop.key.name;
  }

  if (n.StringLiteral.check(prop.key) || n.NumericLiteral.check(prop.key)) {
    return prop.key.value;
  }

  throw new Error('Unexpected property key type');
}

function findObjectPropertyIndex(obj, key) {
  // iterate from the back to find to handle cases like `{ a: 1, a: 2 }`
  for (let i = obj.properties.length - 1; i >= 0; i--) {
    const prop = obj.properties[i];

    if ('key' in prop && String(getPropertyKey(prop)) === String(key)) {
      return i;
    }
  }

  return -1;
}

function findObjectProperty(obj, key) {
  const index = findObjectPropertyIndex(obj, key);

  if (index === -1) {
    return;
  }

  const prop = obj.properties[index];

  if (prop && (n.SpreadElement.check(prop) || n.SpreadProperty.check(prop))) {
    throw new Error('Spread properties are not supported');
  }

  n.ObjectProperty.assert(prop);
  return prop;
}

function findArrayElementWithSingularFallback(node, index) {
  if (n.ArrayExpression.check(node)) {
    return node.elements[index];
  } // this is a singular fallback


  if (index === 0) {
    return node;
  }
} // TODO: this kinda should accept `prop: RecastObjectProperty`
// investigate why it doesn't and if we can change that


const unwrapSimplePropValue = prop => {
  return n.Property.check(prop) || n.ObjectProperty.check(prop) ? prop.value : null;
};

function getSimpleStringValue(prop) {
  return n.StringLiteral.check(prop) ? prop.value : n.TemplateLiteral.check(prop) && prop.quasis.length === 1 ? prop.quasis[0].value.cooked : null;
}

function getTargetValue(prop) {
  return n.Identifier.check(prop) && prop.name === 'undefined' ? undefined : getSimpleStringValue(prop);
}

function getBooleanValue(prop) {
  return n.BooleanLiteral.check(prop) ? prop.value : null;
}

function getStateObjectByPath(object, path) {
  if (path.length === 0) {
    return object;
  }

  const prop = getStatePropByPath(object, path);
  const value = unwrapSimplePropValue(prop);
  n.ObjectExpression.assert(value);
  return value;
}

function getPropByPath(ast, path) {
  if (path.length === 0) {
    throw new Error('As we have to return a *prop* path cannot be empty');
  }

  if (typeof last(path) !== 'string') {
    throw new Error('As we have to return a *prop* the last element of the path must be a string');
  }

  const pathCopy = [...path];
  let segment;
  let current = ast;

  while ((segment = pathCopy.shift()) !== undefined) {
    if (typeof segment === 'string') {
      const prop = findObjectProperty(current, segment);

      if (!prop) {
        return;
      }

      if (pathCopy.length === 0) {
        n.ObjectProperty.assert(prop);
        return prop;
      }

      current = unwrapSimplePropValue(prop);
      continue;
    }

    current = findArrayElementWithSingularFallback(current, segment);

    if (!current) {
      return;
    }
  }
}

function insertAtTransitionPath(ast, path, value) {
  if (typeof last(path) !== 'number') {
    throw new Error('The last element of the path must be a number as we might be adding an array element');
  }

  const pathCopy = path.slice(0, -1);
  let segment;
  let current = ast;

  while ((segment = pathCopy.shift()) !== undefined) {
    const prop = typeof segment === 'string' ? findObjectProperty(current, segment) : findArrayElementWithSingularFallback(current, segment);

    if (!prop) {
      n.ObjectExpression.assert(current);

      if (!pathCopy.length) {
        current.properties.push(b.objectProperty(safePropertyKey(segment), value));
        return;
      }

      const createdProp = b.objectProperty(safePropertyKey(segment), // non-trailing array elements should always be present
      // arrayed invokes should always preexist when adding transitions in them
      // so we can assume that we need to create an object here
      b.objectExpression([]));
      current.properties.push(createdProp);
      current = createdProp.value;
      continue;
    }

    if (!pathCopy.length) {
      n.ObjectProperty.assert(prop);

      if (!n.ArrayExpression.check(prop.value)) {
        prop.value = b.arrayExpression([prop.value]);
      }

      prop.value.elements.splice(last(path), 0, value);
      return;
    }

    let unwrapped = unwrapSimplePropValue(prop);

    if (typeof pathCopy[0] === 'number') {
      const index = pathCopy.shift();

      if (n.ArrayExpression.check(unwrapped)) {
        current = unwrapped.elements[index];
        continue;
      }
    }

    current = unwrapped;
  }
}

function getTransitionObject(obj, path) {
  const pathCopy = [...path];
  let segment;
  let current = obj;

  while ((segment = pathCopy.shift()) !== undefined) {
    const prop = typeof segment === 'string' ? findObjectProperty(current, segment) : findArrayElementWithSingularFallback(current, segment);
    let unwrapped = unwrapSimplePropValue(prop);

    if (typeof pathCopy[0] === 'number') {
      const index = pathCopy.shift();

      if (n.ArrayExpression.check(unwrapped)) {
        if (!pathCopy.length) {
          unwrapped.elements[index] = upgradeSimpleTarget(unwrapped.elements[index]);
        }

        current = unwrapped.elements[index];
        continue;
      }

      if (!pathCopy.length && !n.ObjectExpression.check(unwrapped)) {
        n.ObjectProperty.assert(prop);
        prop.value = upgradeSimpleTarget(unwrapped);
        current = prop.value;
        continue;
      }
    }

    current = unwrapped;
  }

  n.ObjectExpression.assert(current);
  return current;
}

function insertAtActionPath(obj, path, value) {
  if (typeof last(path) !== 'number') {
    throw new Error('The last element of the path must be a number as we might be adding an array element');
  }

  if (path[0] === 'entry' || path[0] === 'exit') {
    insertAtArrayifiableProperty({
      obj,
      property: path[0],
      index: path[1],
      value
    });
    return;
  }

  const transition = getTransitionObject(obj, path.slice(0, -1));
  insertAtArrayifiableProperty({
    obj: transition,
    property: 'actions',
    index: last(path),
    value
  });
}

function editAtActionPath(obj, path, value) {
  if (typeof last(path) !== 'number') {
    throw new Error('The last element of the path must be a number as we might be adding an array element');
  }

  if (path[0] === 'entry' || path[0] === 'exit') {
    editAtArrayifiableProperty({
      obj,
      property: path[0],
      index: path[1],
      value
    });
    return;
  }

  const transition = getTransitionObject(obj, path.slice(0, -1));
  editAtArrayifiableProperty({
    obj: transition,
    property: 'actions',
    index: last(path),
    value
  });
}

function removeAtActionPath(obj, path) {
  if (typeof last(path) !== 'number') {
    throw new Error('The last element of the path must be a number as we might be removing from an array element');
  }

  if (path[0] === 'entry' || path[0] === 'exit') {
    removeAtArrayifiableProperty({
      obj,
      property: path[0],
      index: path[1]
    });
    return;
  }

  const transition = getTransitionObject(obj, path.slice(0, -1));
  const transitionIndex = last(path);
  removeAtArrayifiableProperty({
    obj: transition,
    property: 'actions',
    index: transitionIndex
  });
  updateTransitionAtPathWith(obj, path.slice(0, -1), transition);
}

function insertGuardAtTransitionPath(obj, path, value) {
  const transition = getTransitionObject(obj, path);
  transition.properties.push(b.objectProperty(b.identifier('cond'), value));
}

function editGuardAtTransitionPath(obj, path, value) {
  const transition = getTransitionObject(obj, path);
  const condIndex = findObjectPropertyIndex(transition, 'cond');

  if (condIndex === -1) {
    throw new Error(`"cond" should exist before attempting to remove it`);
  }

  const condProp = transition.properties[condIndex];
  n.ObjectProperty.assert(condProp);
  condProp.value = updateItemType(unwrapSimplePropValue(condProp), value);
}

function removeGuardFromTransition(obj, path) {
  const transition = getTransitionObject(obj, path);
  const condIndex = findObjectPropertyIndex(transition, 'cond');

  if (condIndex === -1) {
    throw new Error(`"cond" should exist before attempting to remove it`);
  }

  removeProperty(transition, 'cond');
  updateTransitionAtPathWith(obj, path, transition);
}

function updateTransitionAtPathWith(obj, path, transition) {
  const minified = minifyTransitionObjectExpression(transition);

  if (!n.ObjectExpression.check(minified)) {
    const transitionProp = getPropByPath(obj, path.slice(0, -1));

    if (n.ArrayExpression.check(transitionProp.value)) {
      if (transitionProp.value.elements.length === 1) {
        transitionProp.value = minified;
        return;
      }

      transitionProp.value.elements[last(path)] = minified;
    } else {
      transitionProp.value = minified;
    }
  }
}

function insertAtArrayifiableProperty({
  obj,
  property,
  index,
  value
}) {
  const propIndex = findObjectPropertyIndex(obj, property);

  if (propIndex === -1) {
    obj.properties.push(b.objectProperty(safePropertyKey(property), value));
    return;
  }

  const unwrapped = unwrapSimplePropValue(obj.properties[propIndex]);

  if (!n.ArrayExpression.check(unwrapped)) {
    const prop = obj.properties[propIndex];
    n.ObjectProperty.assert(prop);
    prop.value = b.arrayExpression([unwrapped]);
  }

  const arr = unwrapSimplePropValue(obj.properties[propIndex]);
  n.ArrayExpression.assert(arr);
  arr.elements.splice(index, 0, value);
}

function removeAtArrayifiableProperty({
  obj,
  property,
  index
}) {
  const propIndex = findObjectPropertyIndex(obj, property);

  if (propIndex === -1) {
    throw new Error(`"${property}" should exist before attempting to remove an item from it`);
  }

  const unwrapped = unwrapSimplePropValue(obj.properties[propIndex]);

  if (n.ArrayExpression.check(unwrapped)) {
    unwrapped.elements.splice(index, 1);

    if (unwrapped.elements.length === 0) {
      removeProperty(obj, property);
    }
  } else {
    removeProperty(obj, property);
  }
}

function editAtArrayifiableProperty({
  obj,
  property,
  index,
  value
}) {
  const propIndex = findObjectPropertyIndex(obj, property);

  if (propIndex === -1) {
    throw new Error(`"${property}" was expected to exist`);
  }

  const prop = obj.properties[propIndex];
  n.ObjectProperty.assert(prop);
  const unwrapped = unwrapSimplePropValue(obj.properties[propIndex]);

  if (!n.ArrayExpression.check(unwrapped)) {
    prop.value = updateItemType(unwrapped, value);
    return;
  }

  unwrapped.elements[index] = updateItemType(unwrapped.elements[index], value);
}

function updateItemType(item, newName) {
  if (n.ObjectExpression.check(item)) {
    const prop = findObjectProperty(item, 'type');
    prop.value = newName;
    return item;
  }

  return newName;
}

function upgradeSimpleTarget(transition) {
  if (!n.ObjectExpression.check(transition)) {
    return b.objectExpression([b.objectProperty(b.identifier('target'), transition)]);
  }

  return transition;
}

function getStatePropByPath(ast, path) {
  const prop = getPropByPath(ast, path.flatMap(segment => ['states', segment]));

  if (!prop) {
    throw new Error('Could not find state');
  }

  return prop;
}

const isValidIdentifier = name => /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);

function safePropertyKey(key) {
  return typeof key === 'number' ? b.numericLiteral(key) : isValidIdentifier(key) ? b.identifier(key) : b.stringLiteral(key);
}

function setPropertyValue(prop, valueNode) {
  if (n.Property.check(prop) || n.ObjectProperty.check(prop)) {
    prop.value = valueNode;
  } else {
    throw new Error('Unsupported property type');
  }
}

const ALLOWED_CALL_EXPRESSION_NAMES = new Set(['createMachine', 'Machine', 'createTestMachine']);

function findRecastDefinitionNode(ast, definitionNode) {
  let recastNode = null;
  recast__namespace.types.visit(ast, {
    visitCallExpression(path) {
      var _argument0$loc, _definitionNode$loc, _argument0$loc2, _definitionNode$loc2, _argument0$loc3, _definitionNode$loc3, _argument0$loc4, _definitionNode$loc4;

      const callee = path.node.callee;
      const argument0 = path.node.arguments[0]; // this check matches the logic for extracting the definition

      if ((n.MemberExpression.check(callee) && n.Identifier.check(callee.property) && ALLOWED_CALL_EXPRESSION_NAMES.has(callee.property.name) || n.Identifier.check(callee) && ALLOWED_CALL_EXPRESSION_NAMES.has(callee.name)) && ((_argument0$loc = argument0.loc) === null || _argument0$loc === void 0 ? void 0 : _argument0$loc.start.line) === ((_definitionNode$loc = definitionNode.loc) === null || _definitionNode$loc === void 0 ? void 0 : _definitionNode$loc.start.line) && ((_argument0$loc2 = argument0.loc) === null || _argument0$loc2 === void 0 ? void 0 : _argument0$loc2.start.column) === ((_definitionNode$loc2 = definitionNode.loc) === null || _definitionNode$loc2 === void 0 ? void 0 : _definitionNode$loc2.start.column) && ((_argument0$loc3 = argument0.loc) === null || _argument0$loc3 === void 0 ? void 0 : _argument0$loc3.end.line) === ((_definitionNode$loc3 = definitionNode.loc) === null || _definitionNode$loc3 === void 0 ? void 0 : _definitionNode$loc3.end.line) && ((_argument0$loc4 = argument0.loc) === null || _argument0$loc4 === void 0 ? void 0 : _argument0$loc4.end.column) === ((_definitionNode$loc4 = definitionNode.loc) === null || _definitionNode$loc4 === void 0 ? void 0 : _definitionNode$loc4.end.column)) {
        recastNode = argument0;
        return false;
      }

      this.traverse(path);
    }

  });
  return recastNode;
}

function arePathsEqual(path1, path2) {
  return path1.length === path2.length && path1.every((p, i) => p === path2[i]);
}

function getIdValue(obj) {
  const idProp = findObjectProperty(obj, 'id');

  if (!idProp) {
    return;
  }

  const idValue = unwrapSimplePropValue(idProp);

  if (!idValue) {
    return;
  }

  return getSimpleStringValue(idValue);
}

function collectAncestorIds(obj, path) {
  const rootId = getIdValue(obj) ?? DEFAULT_ROOT_ID;
  const ids = new Set([rootId]); // we are collecting ids from the root to the current node, but exluding the current node

  const parentPath = path.slice(0, -1);

  for (let i = 0; i < parentPath.length; i++) {
    const segment = parentPath[i];
    obj = getStateObjectByPath(obj, [segment]);
    const id = getIdValue(obj);

    if (id) {
      ids.add(id);
    }
  }

  return ids;
}

function toObjectExpression(obj) {
  return b.objectExpression(Object.entries(obj).map(([key, value]) => {
    if (Array.isArray(value)) {
      throw new Error('Converting arrays is not implemented');
    }

    const valueNode = n.Node.check(value) ? value : typeof value === 'string' ? b.stringLiteral(value) : typeof value === 'boolean' ? b.booleanLiteral(value) : typeof value === 'number' ? b.numericLiteral(value) : typeof value === 'undefined' ? b.identifier('undefined') : value === null ? b.nullLiteral() : typeof value === 'object' ? toObjectExpression(value) : null;

    if (!valueNode) {
      throw new Error('Converting this type of a value to a node has not been implemented');
    }

    return b.objectProperty(safePropertyKey(key), valueNode);
  }));
}

function getBestTargetDescriptor(root, {
  sourcePath,
  targetPath
}) {
  if (!targetPath) {
    return null;
  }

  if (!targetPath.length) {
    return `#${getIdValue(root) || DEFAULT_ROOT_ID}`;
  }

  if (arePathsEqual(sourcePath, targetPath)) {
    return last(targetPath);
  }

  if (arePathsEqual(sourcePath, targetPath.slice(0, sourcePath.length))) {
    return `.${targetPath.slice(sourcePath.length).join('.')}`;
  }

  const isTargetingAncestor = arePathsEqual(sourcePath.slice(0, targetPath.length), targetPath);

  if (!isTargetingAncestor && // this transition might target a state within the renamed sibling
  // we can't just update the segment to the empty string as that would result in targeting own descendant
  targetPath[0] !== '' && arePathsEqual(sourcePath.slice(0, -1), targetPath.slice(0, sourcePath.length - 1))) {
    return targetPath.slice(sourcePath.length - 1).join('.');
  }

  const targetId = getIdValue(getStateObjectByPath(root, targetPath));

  if (targetId) {
    return `#${targetId}`;
  }

  const targetPathCopy = [...targetPath];
  let currentTargetPath = getIdValue(root) || DEFAULT_ROOT_ID;
  let current = root;
  let segment;

  while ((segment = targetPathCopy.shift()) !== undefined) {
    current = getStateObjectByPath(current, [segment]);
    const id = getIdValue(current);

    if (id) {
      currentTargetPath = id;
      continue;
    }

    currentTargetPath += `.${segment}`;
  }

  return `#${currentTargetPath}`;
}

function removeTransitionAtPath(obj, propPath) {
  if (typeof propPath[0] !== 'string') {
    throw new Error('`removeTransitionAtPath` expected the first segmented of the path to be a string. Unwrapping arrays happens inside it');
  }

  const index = findObjectPropertyIndex(obj, propPath[0]);

  if (index === -1) {
    return;
  }

  const prop = obj.properties[index];
  const unwrapped = unwrapSimplePropValue(prop);

  if (typeof propPath[1] === 'string') {
    n.ObjectExpression.assert(unwrapped);
    const removed = removeTransitionAtPath(unwrapped, propPath.slice(1));

    if (unwrapped.properties.length === 0) {
      removeProperty(obj, propPath[0]);
    }

    return removed;
  } // the next segment is the last one (and it's always a number representing the index)
  // we are at the moment at the segment before it


  if (propPath.length === 2) {
    if (n.ArrayExpression.check(unwrapped)) {
      const [removed] = unwrapped.elements.splice(propPath[1], 1);

      switch (unwrapped.elements.length) {
        case 0:
          {
            removeProperty(obj, propPath[0]);
            return removed;
          }

        case 1:
          {
            const prop = obj.properties[index];
            n.ObjectProperty.assert(prop); // array elements should be expressions and property values should be expressions too
            // so this should always be valid in practice

            prop.value = unwrapped.elements[0];
            return removed;
          }

        default:
          {
            return removed;
          }
      }
    }

    removeProperty(obj, propPath[0]);
    return unwrapped;
  }

  const element = findArrayElementWithSingularFallback(unwrapped, propPath[1]);

  if (!element || !n.ObjectExpression.check(element)) {
    throw new Error('Array element was not an object expression');
  } // we are using `.slice(2)` and not `.slice(1)`
  // because we need to "jump over" the unwrapped array index


  return removeTransitionAtPath(element, propPath.slice(2));
}

function getTransitionAtIndex(transition, index) {
  if (n.ArrayExpression.check(transition)) {
    return getTransitionAtIndex(transition.elements[index]);
  }

  if (n.ObjectExpression.check(transition)) {
    return transition;
  }

  return upgradeSimpleTarget(transition);
}

function isExternalTransition(transition) {
  const internalProp = findObjectProperty(transition, 'internal'); // currently it's only safe to trust this value because we only call this function after checking if the transition is an internal candidate

  if (internalProp) {
    const internalValue = unwrapSimplePropValue(internalProp);
    n.BooleanLiteral.assert(internalValue);
    return !internalValue.value;
  }

  const targetProp = findObjectProperty(transition, 'target');

  if (!targetProp) {
    return false;
  }

  const target = getTargetValue(unwrapSimplePropValue(targetProp));

  if (target === null) {
    throw new Error('Unexpected transition target.');
  }

  return typeof target === 'string' ? !target.startsWith('.') : false;
} // perhaps it's a little bit weird that we operate here on the AST level
// but this way we minimize what we touch in the preexisting object expression
// at the same time - this function doesn't fully minify the transition proactively
// it only minifies based on the `override` and if the transition contains only a target prop etc


function minifyTransitionObjectExpression(transitionObject, override) {
  const targetProp = findObjectProperty(transitionObject, 'target');
  const targetValue = targetProp ? getTargetValue(unwrapSimplePropValue(targetProp)) : null;

  if (targetProp && typeof targetValue !== 'string' && targetValue !== undefined) {
    throw new Error('Unexpected transition target');
  }

  const internalProp = findObjectProperty(transitionObject, 'internal');
  const internalValue = internalProp ? getBooleanValue(unwrapSimplePropValue(internalProp)) : undefined;

  if (internalProp && typeof internalValue !== 'boolean') {
    throw new Error(`Unexpected transition's internal value`);
  }

  if (override && 'target' in override) {
    if (typeof override.target === 'string') {
      setProperty(transitionObject, 'target', t__namespace.stringLiteral(override.target));
    } else {
      removeProperty(transitionObject, 'target');
    }
  }

  const finalTargetValue = override && 'target' in override ? override.target : targetValue;

  if (typeof finalTargetValue !== 'string') {
    removeProperty(transitionObject, 'internal');
  } else if ((override === null || override === void 0 ? void 0 : override.internal) === true) {
    if (finalTargetValue.startsWith('.')) {
      removeProperty(transitionObject, 'internal');
    } else {
      setProperty(transitionObject, 'internal', t__namespace.booleanLiteral(true));
    }
  } else if ((override === null || override === void 0 ? void 0 : override.internal) === false) {
    if (finalTargetValue.startsWith('.')) {
      setProperty(transitionObject, 'internal', t__namespace.booleanLiteral(false));
    } else {
      removeProperty(transitionObject, 'internal');
    }
  }

  if (transitionObject.properties.length === 0) {
    return b.identifier('undefined');
  }

  if (transitionObject.properties.length === 1) {
    const targetProp = findObjectProperty(transitionObject, 'target');
    return targetProp ? targetProp.value : transitionObject;
  }

  return transitionObject;
}

function getIndexForTransitionPathAppendant(ast, path) {
  // this function is supposed to ignore the last element (the index)
  // we only want check max existing index of this path in the given state object
  const pathCopy = path.slice(0, -1);
  let segment;
  let current = ast;

  while ((segment = pathCopy.shift()) !== undefined) {
    const prop = typeof segment === 'string' ? findObjectProperty(current, segment) : findArrayElementWithSingularFallback(current, segment);

    if (!prop) {
      return 0;
    }

    if (!pathCopy.length) {
      n.ObjectProperty.assert(prop);

      if (!n.ArrayExpression.check(prop.value)) {
        return 1;
      }

      return prop.value.elements.length;
    }

    let unwrapped = unwrapSimplePropValue(prop);

    if (typeof pathCopy[0] === 'number') {
      const index = pathCopy.shift();

      if (n.ArrayExpression.check(unwrapped)) {
        current = unwrapped.elements[index];
        continue;
      }
    }

    current = unwrapped;
  }

  throw new Error('It should be imposible to get here');
}

function getTransitionExternalValue(previous, next, transition) {
  if (!next.target) {
    return false;
  }

  const isInternalCandidate = arePathsEqual(next.source, next.target.slice(0, next.source.length));

  if (!isInternalCandidate) {
    return true;
  }

  if (!previous.target || !arePathsEqual(previous.source, next.source)) {
    return false;
  }

  const wasAnInternalCandidate = arePathsEqual(previous.source, previous.target.slice(0, previous.source.length));
  return wasAnInternalCandidate && isExternalTransition(transition);
}

function removeState(root, path) {
  const parentState = getStateObjectByPath(root, path.slice(0, -1));
  const statesProp = findObjectProperty(parentState, 'states');
  const unwrapped = unwrapSimplePropValue(statesProp);
  n.ObjectExpression.assert(unwrapped);
  const stateIndex = findObjectPropertyIndex(unwrapped, path[path.length - 1]);
  const removed = unwrapped.properties.splice(stateIndex, 1);

  if (unwrapped.properties.length === 0) {
    const statesIndex = findObjectPropertyIndex(parentState, 'states');
    parentState.properties.splice(statesIndex, 1);
  }

  const removedState = unwrapSimplePropValue(removed[0]);
  n.ObjectExpression.assert(removedState);
  return removedState;
}

function getStatesObjectInState(stateObj) {
  const statesProp = findObjectProperty(stateObj, 'states');

  if (statesProp) {
    const unwrapped = unwrapSimplePropValue(statesProp);
    n.ObjectExpression.assert(unwrapped);
    return unwrapped;
  }

  const statesObj = b.objectExpression([]);
  stateObj.properties.push(b.objectProperty(b.identifier('states'), statesObj));
  return statesObj;
}

function consumeIndentationToNodeAtIndex(fileContent, index) {
  if (typeof index !== 'number') {
    return '';
  }

  let indentation = '';

  while (true) {
    index--;
    const char = fileContent[index];

    if (char === '\n') {
      return indentation;
    }

    if (!/\s/.test(char)) {
      return '';
    }

    indentation = `${char}${indentation}`;
  }
}

function getMachineExtractResult({
  file,
  fileContent,
  node
}) {
  const machineCallResult = MachineCallExpression.parse(node, {
    file,
    getNodeHash: node => {
      const fileText = fileContent.substring(node.start, node.end);
      return hashedId(fileText);
    }
  });
  return machineCallResult && new MachineExtractResult({
    fileAst: file,
    fileContent,
    machineCallResult
  });
}

const extractMachinesFromFile = fileContent => {
  if (!ALLOWED_CALL_EXPRESSION_NAMES$1.some(name => fileContent.includes(name))) {
    return null;
  }

  const {
    file,
    machineNodes
  } = getMachineNodesFromFile(fileContent);
  return {
    machines: machineNodes.map(node => getMachineExtractResult({
      file,
      fileContent,
      node
    })),
    file
  };
};

const groupByUniqueName = arr => {
  const record = new RecordOfArrays();
  arr.forEach(elem => {
    record.add(elem.name, elem);
  });
  return record.toObject();
};

exports.INLINE_IMPLEMENTATION_TYPE = INLINE_IMPLEMENTATION_TYPE;
exports.MachineExtractResult = MachineExtractResult;
exports.StateNode = StateNode;
exports.arrayOf = arrayOf;
exports.dynamicObjectProperty = dynamicObjectProperty;
exports.extractMachinesFromFile = extractMachinesFromFile;
exports.getMachineExtractResult = getMachineExtractResult;
exports.getMachineNodesFromFile = getMachineNodesFromFile;
exports.getPropertiesOfObjectExpression = getPropertiesOfObjectExpression;
exports.groupByUniqueName = groupByUniqueName;
exports.hashedId = hashedId;
exports.isFunctionOrArrowFunctionExpression = isFunctionOrArrowFunctionExpression;
exports.maybeArrayOf = maybeArrayOf;
exports.namedFunctionCall = namedFunctionCall;
exports.objectMethod = objectMethod;
exports.objectOf = objectOf;
exports.objectTypeWithKnownKeys = objectTypeWithKnownKeys;
exports.parserFromBabelMatcher = parserFromBabelMatcher;
exports.spreadElement = spreadElement;
exports.spreadElementReferencingIdentifier = spreadElementReferencingIdentifier;
exports.staticObjectProperty = staticObjectProperty;
Object.keys(types).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return types[k];
    }
  });
});
