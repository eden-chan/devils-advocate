'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var xstate = require('xstate');
var utils = require('xstate/lib/utils');
var machineExtractor = require('@xstate/machine-extractor');
var fs = require('fs/promises');
var path = require('path');
var prettier = require('prettier');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var prettier__namespace = /*#__PURE__*/_interopNamespace(prettier);

function stubAllWith(value) {
  return new Proxy({}, {
    get: () => value
  });
}

function createIntrospectableMachine(machineResult) {
  // xstate-ignore-next-line
  return xstate.createMachine({ ...machineResult.toConfig(),
    context: {},
    predictableActionArguments: true
  }, {
    guards: stubAllWith(() => false),
    actions: machineResult.getChooseActionsToAddToOptions()
  });
}

const isMachineResult = machineResult => machineResult !== undefined;
const filterOutIgnoredMachines = parseResult => {
  return { ...parseResult,
    machines: parseResult.machines.filter(isMachineResult).filter(machine => !machine.getIsIgnored())
  };
};

/**
 * This function takes the AST of a parsed machine (the MachineParseResult)
 * and returns a map of all of its inline implementations (ImplementationsMetadata).
 *
 * Each inline implementation is stored by a hash (its inlineImplemenationId)
 * and stores the raw text of its node.
 */

const getInlineImplementations = (parseResult, fileText) => {
  const allGuards =
  /**
   * We don't ask for 'named' implementations here,
   * since they're not declared inline
   */
  (parseResult === null || parseResult === void 0 ? void 0 : parseResult.getAllConds(['inline', 'identifier', 'unknown'])) || [];
  const allServices = (parseResult === null || parseResult === void 0 ? void 0 : parseResult.getAllServices(['inline', 'identifier', 'unknown'])) || [];
  const allActions = (parseResult === null || parseResult === void 0 ? void 0 : parseResult.getAllActions(['inline', 'identifier', 'unknown'])) || [];
  const inlineImplementations = {
    actions: {},
    guards: {},
    services: {}
  };
  allGuards.forEach(guard => {
    inlineImplementations.guards[
    /**
     * The inlineDeclarationId comes from @xstate/machine-extractor,
     * and is a hash of the inline declaration's text.
     */
    guard.inlineDeclarationId] = {
      jsImplementation: getRawTextFromNode(fileText, guard.node)
    };
  });
  allActions.forEach(action => {
    inlineImplementations.actions[action.inlineDeclarationId] = {
      jsImplementation: getRawTextFromNode(fileText, action.node)
    };
  });
  allServices.forEach(service => {
    if (service.srcNode) {
      inlineImplementations.services[service.inlineDeclarationId] = {
        jsImplementation: getRawTextFromNode(fileText, service.srcNode)
      };
    }
  });
  return inlineImplementations;
};

const getRangeFromSourceLocation = location => {
  return {
    start: {
      character: location.start.column,
      line: location.start.line - 1
    },
    end: {
      character: location.end.column,
      line: location.end.line - 1
    }
  };
};

const getRawTextFromNode = (text, node) => {
  return text.slice(node.start, node.end);
};

const getSetOfNames = arr => {
  const set = new Set();
  arr.forEach(elem => set.add(elem.name));
  return set;
};

// in the future we might want to control the outer quote type ourselves using an additional parameter, so let's use this helper throughout this file
const withSafeQuotes$1 = value => JSON.stringify(value);

const getStateMatchesObjectSyntax = stateSchema => {
  const getUnionForSubState = (subState, depth = 0) => {
    // Do not include sibling states in the union
    // if it's the root
    const states = depth === 0 ? [] : Object.keys(subState).sort().map(state => JSON.stringify(state, (_key, value) => {
      if (typeof value !== 'object') {
        return value;
      }

      return Object.keys(value).reduce((acc, key) => {
        acc[key] = value[key];
        return acc;
      }, {});
    }));
    const substatesWithChildren = Object.entries(subState).filter(([, value]) => {
      return Object.keys(value).length > 0;
    });

    if (substatesWithChildren.length > 0) {
      states.push(`{ ${substatesWithChildren.sort(([stateA], [stateB]) => stateA < stateB ? -1 : 1).map(([state, value]) => {
        return `${withSafeQuotes$1(state)}?: ${getUnionForSubState(value, depth + 1)};`;
      }).join('\n')} }`);
    }

    return `${states.join(' | ')}`;
  };

  return getUnionForSubState(stateSchema);
};

const getTransitionsFromNode = node => {
  const transitions = new Set();

  if (node.parent) {
    Object.keys(node.parent.states).forEach(key => transitions.add(key));
    Object.values(node.parent.states).forEach(siblingNode => {
      getMatchesStates(siblingNode).forEach(key => {
        var _node$parent;

        if (key === siblingNode.path.join('.')) {
          return;
        }

        let relativeKey = key;

        if ((((_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.path.length) || 0) > 0) {
          relativeKey = relativeKey.replace(new RegExp(`^${node.parent.path.join('.')}\.`), '');
        }

        transitions.add(relativeKey);
      });
    });
  }

  Object.values(node.states).map(childNode => {
    getMatchesStates(childNode).map(key => {
      var _childNode$parent;

      let relativeKey = key;

      if ((((_childNode$parent = childNode.parent) === null || _childNode$parent === void 0 ? void 0 : _childNode$parent.path.length) || 0) > 0) {
        relativeKey = relativeKey.replace(new RegExp(`^${childNode.parent.path.join('.')}\.`), '');
      }

      transitions.add(`.${relativeKey}`);
      transitions.add(`${relativeKey}`);
    });
  });
  const rootNode = node.machine;
  const nodesWithId = rootNode.stateIds.filter(id => !/(\.|\(machine\))/.test(id)).map(id => rootNode.getStateNodeById(id));
  nodesWithId.forEach(idNode => {
    getMatchesStates(idNode).forEach(match => {
      if (idNode.id === rootNode.id) {
        transitions.add(`#${idNode.id}.${match}`);
        return;
      }

      transitions.add(match.replace(new RegExp(`^${idNode.path.join('.')}`), `#${idNode.id}`));
    });
  });
  utils.toStatePaths(utils.pathToStateValue(node.path)).forEach(path => {
    if (path.length > 1) {
      transitions.delete(path.join('.'));
    }
  });
  return Array.from(transitions);
};
const getMatchesStates = node => {
  return node.stateIds.flatMap(id => utils.toStatePaths(utils.pathToStateValue(node.getStateNodeById(id).path)).map(path => path.join('.')));
};

const getTsTypesEdits = types => types.filter(type => !type.typesNode.value || type.typesNode.value.argument !== type.data.tsTypesValue.argument || type.typesNode.value.qualifier !== type.data.tsTypesValue.qualifier).map(type => ({
  range: type.typesNode.range,
  newText: `{} as import("${type.data.tsTypesValue.argument}").${type.data.tsTypesValue.qualifier}`
}));

function getRelevantFinalStates(node) {
  switch (node.type) {
    case 'compound':
      return getChildren(node).map(childNode => childNode.type === 'final' ? [childNode] : getRelevantFinalStates(childNode)).flat();

    case 'parallel':
      const finalStatesPerRegion = getChildren(node).map(getRelevantFinalStates);
      return finalStatesPerRegion.every(perRegion => !!perRegion.length) ? finalStatesPerRegion.flat() : [];

    default:
      return [];
  }
}

function getAllNodesToNodes(nodes) {
  const seen = new Set();
  const result = new Set();

  for (const node of nodes) {
    let marker = node;

    while (marker) {
      if (seen.has(marker)) {
        break;
      }

      result.add(marker);
      seen.add(marker);
      marker = marker.parent;
    }
  }

  return result;
}

function getChildren(node) {
  return Object.keys(node.states).map(key => node.states[key]).filter(state => state.type !== 'history');
}

function isWithin(nodeA, nodeB) {
  let marker = nodeB;

  while (marker) {
    if (nodeA === marker) {
      return true;
    }

    marker = marker.parent;
  }

  return false;
}

function findLeastCommonAncestor(machine, nodeA, nodeB) {
  if (!nodeA.path.length || !nodeB.path.length) {
    return machine;
  }

  let i = 0;

  while (true) {
    if (nodeA.path[i] === nodeB.path[i]) {
      i++;
      continue;
    }

    const leastCommonAncestorPath = nodeA.path.slice(0, i);
    let leastCommonAncestor = machine;
    let segment;

    while (segment = leastCommonAncestorPath.shift()) {
      leastCommonAncestor = leastCommonAncestor.states[segment];
    }

    return leastCommonAncestor;
  }
}

const makeStateSchema = node => {
  return Object.fromEntries(getChildren(node).map(child => [child.key, makeStateSchema(child)]));
};

class ItemMap {
  /**
   * The internal map that we use to keep track
   * of all of the items
   */

  /**
   * Check if one of these items is optional -
   * passed in from above via a prop
   */
  constructor(props) {
    this.checkIfOptional = props.checkIfOptional;
    this.map = {};
  }
  /**
   * Add an item to the cache, along with the path of the node
   * it occurs on
   */


  addItem(itemName) {
    if (!this.map[itemName]) {
      this.map[itemName] = {
        events: new Set()
      };
    }
  }
  /**
   * Add a triggering event to an item in the cache, for
   * instance the event type which triggers a guard/action/service
   */


  addEventToItem(itemName, eventType) {
    this.addItem(itemName);

    if (typeof eventType === 'string') {
      this.map[itemName].events.add(eventType);
      return;
    }

    for (const event of eventType) {
      this.map[itemName].events.add(event);
    }
  }
  /**
   * Transform the data into the shape required for index.d.ts
   */


  toDataShape() {
    let isRequiredInTotal = false;
    const lines = Object.entries(this.map).filter(([name]) => {
      return !(name === machineExtractor.INLINE_IMPLEMENTATION_TYPE);
    }).map(([name, data]) => {
      const optional = this.checkIfOptional(name);

      if (!optional) {
        isRequiredInTotal = true;
      }

      return {
        name,
        required: !optional,
        events: Array.from(data.events)
      };
    });
    return {
      lines,
      required: isRequiredInTotal
    };
  }

}

function collectInvokes(ctx, node) {
  node.invoke.forEach(service => {
    const serviceSrc = getServiceSrc(service);

    if (typeof serviceSrc !== 'string' || serviceSrc === machineExtractor.INLINE_IMPLEMENTATION_TYPE) {
      return;
    }

    ctx.services.addItem(serviceSrc);
    const serviceSrcToIdItem = ctx.serviceSrcToIdMap.get(serviceSrc);

    if (serviceSrcToIdItem) {
      serviceSrcToIdItem.add(service.id);
      return;
    }

    ctx.serviceSrcToIdMap.set(serviceSrc, new Set([service.id]));
  });
}

function collectAction(ctx, eventType, actionObject) {
  if (actionObject.type === 'xstate.choose' && Array.isArray(actionObject.conds)) {
    actionObject.conds.forEach(({
      cond,
      actions: condActions
    }) => {
      if (typeof cond === 'string') {
        ctx.guards.addEventToItem(cond, eventType);
      }

      if (Array.isArray(condActions)) {
        condActions.forEach(condAction => {
          if (typeof condAction === 'string') {
            ctx.actions.addEventToItem(condAction, eventType);
          }
        });
      } else if (typeof condActions === 'string') {
        ctx.actions.addEventToItem(condActions, eventType);
      }
    });
  } else {
    ctx.actions.addEventToItem(actionObject.type, eventType);
  }
} // TODO: this doesn't handle
// createMachine(
//   { on: { FOO: { actions: "foo" } } },
//   {
//     actions: {
//       foo: choose([{ cond: "test", actions: "bar" }]),
//       bar: choose([{ cond: "test2", actions: "baz" }]),
//       baz: () => {},
//     },
//   }
// );
// when implementing this consider how it should handle cycles


function collectActions(ctx, eventType, actionObjects) {
  actionObjects.forEach(actionObject => {
    var _ctx$machine$options$;

    collectAction(ctx, eventType, actionObject);
    const actionInOptions = (_ctx$machine$options$ = ctx.machine.options.actions) === null || _ctx$machine$options$ === void 0 ? void 0 : _ctx$machine$options$[actionObject.type];

    if (actionInOptions && typeof actionInOptions === 'object') {
      collectAction(ctx, eventType, actionInOptions);
    }
  });
}

function enterState(ctx, node, eventType) {
  let nodeIdToSourceEventItem = ctx.nodeIdToSourceEventsMap.get(node.id);

  if (nodeIdToSourceEventItem) {
    nodeIdToSourceEventItem.add(eventType);
    return;
  }

  ctx.nodeIdToSourceEventsMap.set(node.id, new Set([eventType]));
}

function exitChildren(ctx, node, eventType, entered = new Set()) {
  getChildren(node).forEach(child => {
    if (entered.has(child)) {
      return;
    }

    collectActions(ctx, eventType, child.onExit);
    exitChildren(ctx, child, eventType, entered);
  });
}

function collectTransitions(ctx, node) {
  node.transitions.forEach(transition => {
    if (transition.cond && transition.cond.name) {
      if (transition.cond.name !== 'cond') {
        ctx.guards.addEventToItem(transition.cond.name, transition.eventType);
      }
    }

    collectActions(ctx, transition.eventType, transition.actions);

    if (!transition.target || !transition.target.length) {
      return;
    }

    transition.target.forEach(target => {
      if (isWithin(node, target)) {
        const enteredSet = new Set();
        let marker = target;

        while (marker) {
          if (marker === node) {
            break;
          }

          enteredSet.add(marker);
          marker = marker.parent;
        }

        if (!transition.internal) {
          enteredSet.add(marker);
        }

        enteredSet.forEach(entered => {
          enterState(ctx, entered, transition.eventType);
        });
        exitChildren(ctx, node, transition.eventType, enteredSet);

        if (!transition.internal) {
          collectActions(ctx, transition.eventType, node.onExit);
        }
      } else {
        exitChildren(ctx, node, transition.eventType);
        collectActions(ctx, transition.eventType, node.onExit);
        const leastCommonAncestor = findLeastCommonAncestor(ctx.machine, node, target);
        let marker = node;

        while (true) {
          if (marker === leastCommonAncestor) {
            break;
          }

          collectActions(ctx, transition.eventType, marker.onExit);
          marker = marker.parent;
        }

        const enteringPath = target.path.slice(leastCommonAncestor.path.length);
        let segment;
        marker = leastCommonAncestor;

        while (segment = enteringPath.shift()) {
          marker = marker.states[segment];
          enterState(ctx, marker, transition.eventType);
        }
      }
    });
  });
}

function createTraversalContext(machine) {
  return {
    machine,
    serviceSrcToIdMap: new Map(),
    nodeIdToSourceEventsMap: new Map(),
    actions: new ItemMap({
      checkIfOptional: name => {
        var _machine$options, _machine$options$acti;

        return Boolean((_machine$options = machine.options) === null || _machine$options === void 0 ? void 0 : (_machine$options$acti = _machine$options.actions) === null || _machine$options$acti === void 0 ? void 0 : _machine$options$acti[name]);
      }
    }),
    delays: new ItemMap({
      checkIfOptional: name => {
        var _machine$options2, _machine$options2$del;

        return Boolean((_machine$options2 = machine.options) === null || _machine$options2 === void 0 ? void 0 : (_machine$options2$del = _machine$options2.delays) === null || _machine$options2$del === void 0 ? void 0 : _machine$options2$del[name]);
      }
    }),
    guards: new ItemMap({
      checkIfOptional: name => {
        var _machine$options3, _machine$options3$gua;

        return Boolean((_machine$options3 = machine.options) === null || _machine$options3 === void 0 ? void 0 : (_machine$options3$gua = _machine$options3.guards) === null || _machine$options3$gua === void 0 ? void 0 : _machine$options3$gua[name]);
      }
    }),
    services: new ItemMap({
      checkIfOptional: name => {
        var _machine$options4, _machine$options4$ser;

        return Boolean((_machine$options4 = machine.options) === null || _machine$options4 === void 0 ? void 0 : (_machine$options4$ser = _machine$options4.services) === null || _machine$options4$ser === void 0 ? void 0 : _machine$options4$ser[name]);
      }
    })
  };
}

// simple information is an information that doesn't need dereferencing target states
function collectSimpleInformation(ctx, node) {
  // TODO: history states are not handled yet
  collectInvokes(ctx, node);
  collectActions(ctx, 'xstate.stop', node.onExit);
  collectTransitions(ctx, node);
  getChildren(node).forEach(childNode => collectSimpleInformation(ctx, childNode));
}

function collectEnterables(ctx, node) {
  const sourceEvents = ctx.nodeIdToSourceEventsMap.get(node.id);

  if (!sourceEvents) {
    getChildren(node).forEach(child => collectEnterables(ctx, child));
    return;
  }

  const enterableNodes = new Set([node]);
  const initialLeafNodes = node.initialStateNodes;
  let current;

  while (current = initialLeafNodes.pop()) {
    let marker = current;

    while (marker !== node) {
      enterableNodes.add(marker);
      marker = marker.parent;
    }
  }

  enterableNodes.forEach(enterableNode => {
    enterableNode.invoke.forEach(service => {
      const serviceSrc = getServiceSrc(service);

      if (typeof serviceSrc !== 'string') {
        return;
      }

      sourceEvents.forEach(eventType => {
        ctx.services.addEventToItem(serviceSrc, eventType);
      });
    });
    enterableNode.after.forEach(({
      delay
    }) => {
      if (typeof delay === 'string') {
        sourceEvents.forEach(source => {
          ctx.delays.addEventToItem(delay, source);
        });
      }
    });
    collectActions(ctx, sourceEvents, enterableNode.onEntry);
  });
  getChildren(node).forEach(child => collectEnterables(ctx, child));
}

function collectEventsLeadingToFinalStates(ctx) {
  const relevantFinalStates = new Set(getRelevantFinalStates(ctx.machine));
  const leafParallelSeenMap = new Map();

  for (const finalState of relevantFinalStates) {
    const sourceEvents = ctx.nodeIdToSourceEventsMap.get(finalState.id);

    if (!sourceEvents) {
      continue;
    }

    const seenEvents = new Set();
    const seenStates = new Set();

    for (const eventType of sourceEvents) {
      seenEvents.add(eventType);
    }

    let marker = finalState;

    while (marker) {
      var _marker$parent;

      seenStates.add(marker);
      collectActions(ctx, sourceEvents, marker.onExit);

      if (((_marker$parent = marker.parent) === null || _marker$parent === void 0 ? void 0 : _marker$parent.type) === 'parallel') {
        leafParallelSeenMap.set(marker, {
          events: seenEvents,
          nodes: seenStates
        });
        break;
      }

      marker = marker.parent;
    }
  }

  for (const [leafParallel, seen] of leafParallelSeenMap) {
    for (const [otherParallel, otherSeen] of leafParallelSeenMap) {
      if (otherParallel === leafParallel) {
        continue;
      }

      for (const node of otherSeen.nodes) {
        collectActions(ctx, seen.events, node.onExit);
      }
    }
  }

  const eventsLeadingToFinalStates = new Set(Array.from(leafParallelSeenMap.values()).flatMap(({
    events
  }) => Array.from(events)));
  getAllNodesToNodes(Array.from(leafParallelSeenMap.keys())).forEach(node => {
    collectActions(ctx, eventsLeadingToFinalStates, node.onExit);
  });
}

const introspectMachine = machine => {
  const ctx = createTraversalContext(machine);
  collectSimpleInformation(ctx, machine);
  enterState(ctx, machine, 'xstate.init');
  collectEnterables(ctx, machine);
  collectEventsLeadingToFinalStates(ctx);
  return {
    states: machine.stateIds.map(id => ({
      id,
      sources: ctx.nodeIdToSourceEventsMap.get(id) || new Set()
    })),
    stateSchema: makeStateSchema(machine),
    guards: ctx.guards.toDataShape(),
    actions: ctx.actions.toDataShape(),
    services: ctx.services.toDataShape(),
    delays: ctx.delays.toDataShape(),
    serviceSrcToIdMap: ctx.serviceSrcToIdMap
  };
};

const getServiceSrc = invoke => {
  if (typeof invoke.src === 'string') {
    return invoke.src;
  }

  return invoke.src.type;
};

const removeExtension = fileName => fileName.replace(/\.[^/.]+$/, '');

const isInlineServiceId = id => /:invocation\[\d+\]$/.test(id);

const getTypegenData = (fileName, machineIndex, machineResult) => {
  var _machineResult$machin, _machineResult$machin2, _tsTypes$typeAnnotati;

  const introspectResult = introspectMachine(createIntrospectableMachine(machineResult));
  const tsTypes = (_machineResult$machin = machineResult.machineCallResult.definition) === null || _machineResult$machin === void 0 ? void 0 : (_machineResult$machin2 = _machineResult$machin.tsTypes) === null || _machineResult$machin2 === void 0 ? void 0 : _machineResult$machin2.node;
  const providedImplementations = getProvidedImplementations(machineResult);
  const actions = introspectResult.actions.lines.filter(line => !line.name.startsWith('xstate.'));
  const delays = introspectResult.delays.lines.filter(line => !line.name.startsWith('xstate.'));
  const guards = introspectResult.guards.lines.filter(line => !line.name.startsWith('xstate.'));
  const services = introspectResult.services.lines.filter(line => !line.name.startsWith('xstate.'));
  const allServices = machineResult.getAllServices(['named']).map(elem => ({
    src: elem.src,
    id: elem.id
  })) || [];
  return {
    typesNode: {
      range: [{
        line: tsTypes.loc.start.line - 1,
        column: tsTypes.loc.start.column,
        index: tsTypes.start
      }, {
        line: tsTypes.loc.end.line - 1,
        column: tsTypes.loc.end.column,
        index: tsTypes.end
      }],
      value: tsTypes.type === 'TSAsExpression' && tsTypes.typeAnnotation.type === 'TSImportType' && ((_tsTypes$typeAnnotati = tsTypes.typeAnnotation.qualifier) === null || _tsTypes$typeAnnotati === void 0 ? void 0 : _tsTypes$typeAnnotati.type) === 'Identifier' ? {
        argument: tsTypes.typeAnnotation.argument.value,
        qualifier: tsTypes.typeAnnotation.qualifier.name
      } : null
    },
    // we sort strings here because we use deep comparison to detect a change in the output of this function
    data: {
      tsTypesValue: {
        argument: `./${removeExtension(fileName)}.typegen`,
        qualifier: `Typegen${machineIndex}`
      },
      internalEvents: collectPotentialInternalEvents([introspectResult.actions.lines, introspectResult.services.lines, introspectResult.guards.lines, introspectResult.delays.lines], allServices),
      serviceSrcToIdMap: Object.fromEntries(Array.from(introspectResult.serviceSrcToIdMap).filter(([src]) => allServices.some(service => service.src === src)).sort(([srcA], [srcB]) => srcA < srcB ? -1 : 1).map(([src, ids]) => [src, Array.from(ids).sort()])),
      missingImplementations: {
        actions: getMissingImplementationsForType(actions, providedImplementations.actions),
        delays: getMissingImplementationsForType(delays, providedImplementations.delays),
        guards: getMissingImplementationsForType(guards, providedImplementations.guards),
        services: getMissingImplementationsForType(services, providedImplementations.services).filter(id => !isInlineServiceId(id))
      },
      eventsCausingActions: getEventsCausing(actions),
      eventsCausingDelays: getEventsCausing(delays),
      eventsCausingGuards: getEventsCausing(guards),
      eventsCausingServices: Object.fromEntries(Object.entries(getEventsCausing(services)).filter(([id]) => !isInlineServiceId(id))),
      // this is an object so it's not worth sorting it here
      stateSchema: introspectResult.stateSchema,
      tags: Array.from(new Set((machineResult === null || machineResult === void 0 ? void 0 : machineResult.getAllStateNodes().flatMap(node => {
        var _node$ast$tags;

        return ((_node$ast$tags = node.ast.tags) === null || _node$ast$tags === void 0 ? void 0 : _node$ast$tags.map(tag => tag.value)) || [];
      })) || [])).sort()
    }
  };
};

const getProvidedImplementations = machine => {
  var _machine$machineCallR, _machine$machineCallR2, _machine$machineCallR3, _machine$machineCallR4, _machine$machineCallR5, _machine$machineCallR6, _machine$machineCallR7, _machine$machineCallR8;

  return {
    actions: new Set(((_machine$machineCallR = machine.machineCallResult.options) === null || _machine$machineCallR === void 0 ? void 0 : (_machine$machineCallR2 = _machine$machineCallR.actions) === null || _machine$machineCallR2 === void 0 ? void 0 : _machine$machineCallR2.properties.map(property => property.key)) || []),
    delays: new Set(((_machine$machineCallR3 = machine.machineCallResult.options) === null || _machine$machineCallR3 === void 0 ? void 0 : (_machine$machineCallR4 = _machine$machineCallR3.delays) === null || _machine$machineCallR4 === void 0 ? void 0 : _machine$machineCallR4.properties.map(property => property.key)) || []),
    guards: new Set(((_machine$machineCallR5 = machine.machineCallResult.options) === null || _machine$machineCallR5 === void 0 ? void 0 : (_machine$machineCallR6 = _machine$machineCallR5.guards) === null || _machine$machineCallR6 === void 0 ? void 0 : _machine$machineCallR6.properties.map(property => property.key)) || []),
    services: new Set(((_machine$machineCallR7 = machine.machineCallResult.options) === null || _machine$machineCallR7 === void 0 ? void 0 : (_machine$machineCallR8 = _machine$machineCallR7.services) === null || _machine$machineCallR8 === void 0 ? void 0 : _machine$machineCallR8.properties.map(property => property.key)) || [])
  };
};

const collectPotentialInternalEvents = (lineArrays, services) => unique(lineArrays.flatMap(lines => lines.flatMap(line => line.events)).filter(event => event === '' || // TODO: we should source those from the machine config properties like after, invoke, etc
// OTOH, maybe for the the optimized output we should actually rely on the events that can be given to available implementations
// in such a case though the `services.flatMap(...)` below would be redundant
/^(xstate|done\.invoke|error\.platform)\./.test(event)).concat('xstate.init', services.flatMap(service => // TODO: is this correct? shouldn't we also generate events for services without an id?
service.id ? [`done.invoke.${service.id}`, `error.platform.${service.id}`] : []))).sort();

const getMissingImplementationsForType = (usedImplementations, providedImplementations) => {
  return usedImplementations.map(usedImplementation => usedImplementation.name).filter(usedImplementation => !providedImplementations.has(usedImplementation)).sort();
};

const getEventsCausing = lines => {
  return Object.fromEntries(lines.sort((lineA, lineB) => lineA.name < lineB.name ? -1 : 1).map(line => [line.name, unique(line.events).sort()]));
};

const unique = array => Array.from(new Set(array));

// in the future we might want to control the outer quote type ourselves using an additional parameter, so let's use this helper throughout this file
const withSafeQuotes = value => JSON.stringify(value);

const getTypegenOutput = types => {
  return `
  // This file was automatically generated. Edits will be overwritten

  ${types.map(({
    data: typegenData
  }, index) => {
    return `export interface Typegen${index} {
        '@@xstate/typegen': true;
        internalEvents: {
          ${typegenData.internalEvents.map(event => {
      const safeEvent = withSafeQuotes(event);

      if (event.startsWith('done.invoke.')) {
        return `${safeEvent}: { type: ${safeEvent}; data: unknown; __tip: "See the XState TS docs to learn how to strongly type this." };`;
      }

      if (event.startsWith('error.platform.')) {
        return `${safeEvent}: { type: ${safeEvent}; data: unknown };`;
      }

      return `${safeEvent}: { type: ${safeEvent} };`;
    }).join('\n')}
        };
        invokeSrcNameMap: {
          ${Object.entries(typegenData.serviceSrcToIdMap).map(([src, ids]) => `${withSafeQuotes(src)}: ${toUnion(ids.map(id => `done.invoke.${id}`))};`).join('\n')}
        };
        missingImplementations: {
          actions: ${toUnionOrNever(typegenData.missingImplementations.actions)};
          delays: ${toUnionOrNever(typegenData.missingImplementations.delays)};
          guards: ${toUnionOrNever(typegenData.missingImplementations.guards)};
          services: ${toUnionOrNever(typegenData.missingImplementations.services)};
        };
        eventsCausingActions: {
          ${Object.entries(typegenData.eventsCausingActions).map(([action, events]) => `${withSafeQuotes(action)}: ${toUnionOrNever(events)};`).join('\n')}
        };
        eventsCausingDelays: {
          ${Object.entries(typegenData.eventsCausingDelays).map(([delay, events]) => `${withSafeQuotes(delay)}: ${toUnionOrNever(events)};`).join('\n')}
        };
        eventsCausingGuards: {
          ${Object.entries(typegenData.eventsCausingGuards).map(([guard, events]) => `${withSafeQuotes(guard)}: ${toUnionOrNever(events)};`).join('\n')}
        };
        eventsCausingServices: {
          ${Object.entries(typegenData.eventsCausingServices).map(([service, events]) => `${withSafeQuotes(service)}: ${toUnionOrNever(events)};`).join('\n')}
        };
        matchesStates: ${printMatchesStates(typegenData.stateSchema)};
        tags: ${toUnionOrNever(typegenData.tags)};
      }`;
  }).join('\n\n')}
  `;
};

const toPaths = stateSchema => {
  return Object.entries(stateSchema).flatMap(([key, value]) => [key, ...toPaths(value).map(path => `${key}.${path}`)]);
};

const printMatchesStates = stateSchema => {
  if (!Object.keys(stateSchema).length) {
    return 'undefined';
  }

  const stringSyntax = toUnion(toPaths(stateSchema).sort());
  const objectSyntax = getStateMatchesObjectSyntax(stateSchema);

  if (objectSyntax) {
    return `${stringSyntax} | ${objectSyntax}`;
  }

  return `${stringSyntax}`;
};

const toUnion = arr => arr.map(withSafeQuotes).join(' | ');

const toUnionOrNever = arr => arr.length ? toUnion(arr) : 'never';

const isCursorInPosition = (nodeSourceLocation, cursorPosition) => {
  if (!nodeSourceLocation) return;
  const isOnSameLine = nodeSourceLocation.start.line - 1 === cursorPosition.line;
  const isWithinChars = cursorPosition.character >= nodeSourceLocation.start.column && cursorPosition.character <= nodeSourceLocation.end.column;

  if (isOnSameLine) {
    return isWithinChars;
  }

  const isWithinLines = cursorPosition.line >= nodeSourceLocation.start.line - 1 && cursorPosition.line <= nodeSourceLocation.end.line;
  return isWithinLines;
};

const processFileEdits = (oldText, textEdits) => {
  const sortedEdits = [...textEdits].sort((a, b) => b.range[0].index - a.range[0].index);
  let newText = oldText;

  for (const edit of sortedEdits) {
    newText = newText.slice(0, edit.range[0].index) + edit.newText + newText.slice(edit.range[1].index);
  }

  return newText;
};

async function removeFile(filePath) {
  try {
    await fs__namespace.unlink(filePath);
  } catch (e) {
    if ((e === null || e === void 0 ? void 0 : e.code) === 'ENOENT') {
      return;
    }

    throw e;
  }
}

// TODO: remove it if possible or add a comment on why it's needed
const resolveUriToFilePrefix = uri => {
  if (!uri.startsWith('file://')) {
    return `file://${uri}`;
  }

  return uri;
};

const writeToTypegenFile = async (filePath, types) => {
  const pathToSave = filePath.slice(0, -path__namespace.extname(filePath).length) + '.typegen.ts';

  if (!types.length) {
    await removeFile(pathToSave);
    return;
  }

  await fs__namespace.writeFile(pathToSave, prettier__namespace.format(getTypegenOutput(types), { ...(await prettier__namespace.resolveConfig(filePath)),
    parser: 'typescript'
  }));
};

exports.createIntrospectableMachine = createIntrospectableMachine;
exports.filterOutIgnoredMachines = filterOutIgnoredMachines;
exports.getInlineImplementations = getInlineImplementations;
exports.getMatchesStates = getMatchesStates;
exports.getRangeFromSourceLocation = getRangeFromSourceLocation;
exports.getRawTextFromNode = getRawTextFromNode;
exports.getSetOfNames = getSetOfNames;
exports.getStateMatchesObjectSyntax = getStateMatchesObjectSyntax;
exports.getTransitionsFromNode = getTransitionsFromNode;
exports.getTsTypesEdits = getTsTypesEdits;
exports.getTypegenData = getTypegenData;
exports.getTypegenOutput = getTypegenOutput;
exports.introspectMachine = introspectMachine;
exports.isCursorInPosition = isCursorInPosition;
exports.isMachineResult = isMachineResult;
exports.processFileEdits = processFileEdits;
exports.removeFile = removeFile;
exports.resolveUriToFilePrefix = resolveUriToFilePrefix;
exports.writeToTypegenFile = writeToTypegenFile;
